#!/usr/bin/env python
#
# uconvert - universal file conversion script
VERSION="0.90"
# Author: Scott Kuhl
# Website: http://www.cs.mtu.edu/~kuhl/software/makelatex

# This program attempts to create the requested files using a variety of
# conversions specified in a configuration file. The configuration file can
# be named .uconvert.conf or uconvert.conf and can be placed in ~,
# ~/.config/uconvert/, /etc, or the current directory.
#
# EXAMPLE: If you have image.svg, and you would like to convert the image
# into a PNG file, simply request a PNG file with: "uconvert image.png"
#
# SECURITY: Any command in your configuration file could be run by
# uconvert. You should make sure trust anyone who has access to write to it.
#
#
# Copyright (C) 2009--2012 Scott A. Kuhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.



import string, subprocess, os, sys, shutil, threading, time

# Directories to look for configuration files (named ".uconvert" or "uconvert.conf"):
CONFIG_DIRS = os.path.expanduser('~') + ":" + os.path.expanduser('~') + "/.config/uconvert:/etc:."
THREADS=True   # start each argument in its own thread
VERBOSE=1


class bcolors:
    FAIL = '\033[91m\033[1m'  # red, bold
    WARN = '\033[93m\033[1m'  # yellow, bold
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

def printError(msg):
    print(bcolors.FAIL + msg + bcolors.ENDC)
def printWarn(msg):
    print(bcolors.WARN + msg + bcolors.ENDC)



# returns the next line that isn't empty/commented out.  If we reached the
# end of the file, return 0.
def getline(infile):

    while infile:
        line = infile.readline()

        if len(line) == 0:
            return 0

        line.strip()

        if str.isspace(line):
            continue

        elif line[0] == '#':
            continue

        else:
            return line

def humanSize(num):
    for x in ['bytes','KiB','MiB','GiB','TiB']:
        if num < 1024.0:
            return "%d%s" % (round(num), x)
        num /= 1024.0


# If a suitable conversion has been found in ~/.uconvert, runcommand()
# runs the conversion command.  An appropriate source file should exist
# before calling runcommand.
#
# command:  The command to run
# inexten:  The extension of the source file
# outexten: The requested file extension
# base:     The basename of the file (source and destination)
# indir:    The directory where the file can be found
# outdir:   The location where the output file should be created
def runcommand(command, inexten, outexten, base, indir, outdir):

    # Note that base can have a directory as a part of it.  We will change
    # into that directory though...so strip it off here.
    command = command.replace("BASE", str.split(base, "/")[-1])
    command = command.replace("IN",   inexten)
    command = command.replace("OUT",  outexten)

    # Store the complete paths to the files
    filein = indir  + "/" + base + "." + inexten
    fileout = outdir + "/" + base + "." + outexten

    # Ensure that the source file exists.
    if not os.path.exists(filein):
        printError("uconvert: ERROR: You called runcommand with an nonexistant input file")
        return 0 # fail

    fileinstat  = os.stat(filein)

    # create output directory if it doesn't exist
    if not os.path.exists(os.path.dirname(outdir + "/" + base)):
        os.makedirs(os.path.dirname(outdir + "/" + base))

    # if output file already exists, check if we need to regenerate it (by
    # looking at modification time)
    if os.path.exists(fileout):
        fileoutstat = os.stat(fileout)

        if fileinstat.st_mtime <= fileoutstat.st_mtime:
            if VERBOSE >= 2:
                print("uconvert: " + base+"."+outexten+" ("+humanSize(fileoutstat.st_size)+"): No update needed.")
                sys.stdout.flush()
            return 1 # success

    ruleName = command.split(" ")[0]
    if not findFileInPaths(command.split(" ")[0]):
        print("uconvert: Skipping rule because \"" + ruleName + "\" is not available; trying other rules...")
        return False


    # Run the command in the directory of the source file
    command = "cd " + os.path.dirname(indir+"/"+base) + " && " + command
    if VERBOSE >= 3: print(command)

    # Run the command
    if subprocess.call(["/usr/bin/env", "bash", "-c", command]) == 0:
        # ... if the command returned a normal return value....

        # check if output file was created (it should be in the same
        # directory as the input file)
        if os.path.exists(indir + "/" + base + "." + outexten):

            # move the file we made into the output directory
            shutil.move( indir+"/"+base+"."+outexten, fileout )

            # get size information on our new file
            fileoutstat = os.stat(fileout)

            # Print the filenames of what we converted...not the paths
            print("uconvert: " + base+"."+outexten +" ("+humanSize(fileoutstat.st_size)+") <-- " + base+"."+inexten+" ("+humanSize(fileinstat.st_size)+") using " + ruleName)
            sys.stdout.flush()
            return True  # success

        else:  # program ran properly, but the output file wasn't created
            printError("uconvert: ERROR " + fileout + ": Running command didn't create file! Command: " + command)
            sys.stdout.flush()
            return False # fail
    else:
        printError("uconvert: ERROR: " + fileout + ": Command failed: " + command)
        sys.stdout.flush()
        return False  # program failed

# set destfile to have the same modified time as the srcfile.
def updateMtime(srcfile, destfile):
    fileinstat = os.stat(srcfile)
    os.utime(destfile, (fileinstat.st_mtime+.01, fileinstat.st_mtime+.01))


# convertfile() is called once for every conversion rule in ~/.uconvert.
#
# inlist is a list of extensions in the IN: line in ~/.uconvert
# outlist is a list of extension in the OUT: line in ~/.uconvert
# command is a the string after COMMAND: in ~/.uconvert
# request is the requested file.
def convertfile(inlist, outlist, command, request):

    requestBase  = request.rsplit(".", 1)[0]
    requestExten = request.rsplit(".", 1)[1]

    global SRC_DIR
    global DEST_DIR

    for path in SRC_DIR: # for all paths
        # If the output is a different directory than the source directory and
        # the requested file is already in the source directory, just copy it
        # over!

        if DEST_DIR != path and os.path.exists(path + "/" + request):

            # create output directory if it doesn't exist
            try:
#            if not os.path.exists(os.path.dirname(DEST_DIR + "/" + request)):
                os.makedirs(os.path.dirname(DEST_DIR + "/" + request))
            except OSError:
                # directory already exists (or we can't create directory).
                # We need to just allow this because some other thread
                # may have created the path for us
                pass

            shutil.copy(path + "/" + request,
                        DEST_DIR + "/" + request)
            updateMtime(path + "/" + request,
                        DEST_DIR + "/" + request)

            if VERBOSE >= 2:
                print("uconvert: Copy  " + request + ": Copied to destination.")
            return 1 # success



    if requestExten in outlist:  # if our requested extension can be output
        for item in inlist:      # for all of the input extensions
            for path in SRC_DIR: # and for all paths
                if item != requestExten:  # if the source and requested extension are different
                    # and if the source file exists
                    if os.path.exists(path + "/" + requestBase + "." + item):
                        ret = runcommand(command, item, requestExten, requestBase, path, DEST_DIR)
                        if ret == True:
                            updateMtime(path + "/" + requestBase + "." + item,
                                        DEST_DIR + "/" + request)
                            return True


    return 0


# Given a colon-delimited set of paths and a filename, look for the file in
# the paths and return path (or None if it doesn't exist in paths)
def findFileInPaths(name, paths=os.environ['PATH']):
    for path in paths.split(os.pathsep):
        f = os.path.join(path, name)
        if os.path.exists(f):
            return f
    return None



def processFile(arg):
    confFilename = findFileInPaths(".uconvert", CONFIG_DIRS)
    if not confFilename:
        confFilename = findFileInPaths("uconvert.conf", CONFIG_DIRS)
    if not confFilename:
        printError("uconvert ERROR: Can't find .uconvert or uconvert.conf in any of these directories:")
        print(CONFIG_DIRS)
        exit(1)

    conf = open( confFilename , "r")
    line = getline(conf)

    success = 0
    while line != 0 and success == 0:
        line_in      = line.lstrip("IN: ")
        line_out     = getline(conf).lstrip("OUT: ")
        line_command = getline(conf).lstrip("COMMAND: ")

        line = getline(conf)

        if convertfile(line_in.split(),
                       line_out.split(),
                       line_command, arg):
            success = 1

    if success == 0:
        if os.path.exists(arg):
            if VERBOSE >= 1:
                printWarn("uconvert WARNING: \"" + arg + "\" exists, but can't find file it was created from.")
        else:
            printError("uconvert ERROR: Missing source file or a conversion rule to create \"" + arg + "\".")


def initialSetup():

    if len(sys.argv) == 1 or "-h" in sys.argv or "--help" in sys.argv:
        print("Usage: ")
        print(sys.argv[0] + " [args] file1.eps file2.png ...")
        print("")
        print("Description: Creates the requested files.")
        print("")
        print("Arguments:")
        print("  -v --verbose   Display conversion commands.")
        print("  -q --quiet     Display only errors and warnings. (default)")
        print("  -s --silent    Display only errors.")
        print("  -h --help      Display this help message.")
        print("")
        print("Author: Scott Kuhl")
        print("Program version: " + VERSION)
        sys.exit(1)

    global args
    args = sys.argv
    args.remove(args[0])  # remove the program name


    # 0 = only errors
    # 1 = errors and warnings
    # 2 = information, errors, warnings and no-ups
    # 3 = everything
    global VERBOSE
    if "-v" in args:
        args.remove("-v")
        VERBOSE=3
    if "--verbose" in args:
        args.remove("--verbose")
        VERBOSE=3

    if "-q" in args:
        args.remove("-q")
        VERBOSE=1
    if "--quiet" in args:
        args.remove("--quiet")
        VERBOSE=1

    if "-s" in args:
        args.remove("-s")
        VERBOSE=0
    if "--silent" in args:
        args.remove("--silent")
        VERBOSE=0



    # Directory to place output files
    global DEST_DIR
    DEST_DIR=os.getenv("UCONVERT_DEST_DIR")

    if DEST_DIR and len(DEST_DIR) != 0:
        if VERBOSE >= 2:
            print("Putting output files in: " + DEST_DIR)
    else:
        DEST_DIR="."
        if VERBOSE >= 2:
            print("Putting output files in current directory.")


    # A colon seperated list of paths to look for source files
    global SRC_DIR
    SRC_DIR = os.getenv("UCONVERT_SRC_DIR")

    if SRC_DIR and len(SRC_DIR) != 0:
        SRC_DIR = str.split(SRC_DIR,  ":")
        if VERBOSE >= 2:
            print("Looking for source files in:" + os.getenv("UCONVERT_SRC_DIR"))
    else:
        SRC_DIR = [ "." ]  # just use the current directory
        if VERBOSE >= 2:
            print("Looking for source file in current directory.")




initialSetup()

for arg in args:
    if THREADS:
        threading.Thread(target=processFile,args=(arg,)).start()
    else:
        processFile(arg)

if THREADS:
    while threading.activeCount() > 1:
        time.sleep(.2)

