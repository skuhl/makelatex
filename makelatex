#!/usr/bin/env python
#
# makelatex - version: 0.95dev
# http://www.cs.mtu.edu/~kuhl/software/makelatex
#
#
# Copyright (C) 2011--2014 Scott A. Kuhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
class makelatexUtil:
    @staticmethod
    def compressuser(path):
        """Performs the opposite of path.os.expanduser(): Changes /home/username into ~"""
        return re.sub(os.path.expanduser('~'), '~', path)
    @staticmethod
    def humanSize(num):
        """Given a number of bytes, returns a human-readable string representing the file size."""
        for x in ['bytes','KiB','MiB','GiB','TiB']:
            if num < 1024.0:
                return "%d%s" % (round(num), x)
            num /= 1024.0
    @staticmethod
    def updateMtime(srcfile, destfile):
        """Set the last modified time of destfile to match the last modified time of source file."""
        fileinstat = os.stat(srcfile)
        os.utime(destfile, (fileinstat.st_mtime+.01, fileinstat.st_mtime+.01))
    @staticmethod
    def findFileInPaths(name, paths=None, kpathsea=False):
        """Given a colon-delimited set of paths and a filename, look for the file in the paths and return path (or None if it doesn't exist in paths). If kpathsea is set, we look for tex system files that match."""
        if not paths:
            paths=os.environ['PATH']
        # if kpathsea:
        #     origEnviron = makelatexUtil.getEnviron("TEXINPUTS")
        #     os.environ["TEXINPUTS"]=paths
        #     path = os.popen("kpsewhich \""+name+"\"").read().strip()
        #     os.environ["TEXINPUTS"]=origEnviron
        #     if len(path):
        #         return path
        #     else:
        #         return None

        for path in paths.split(os.pathsep):
            f = os.path.join(path, name)
            if os.path.exists(f):
                return f
        return None
    @staticmethod
    def dedup(listin):
        """Removes duplicates in list."""
        out = []
        for i in listin:
            if out.count(i) == 0:
                out.append(i)
        return out
    @staticmethod
    def pathOnly(path):
        """Converts a path to a file to the path only (removes everything after the last '/'). Result contains trailing '/'"""
        t = os.path.split(path)[0]
        if not t.endswith(os.sep):
            t = t + os.sep
        return t
    @staticmethod
    def fileOnly(path):
        """Converts a path string into a filename (removes everything before the last '/')"""
        return os.path.split(path)[1]
    @staticmethod
    def bname(path):
        """Returns the basename (filename without extension) given a full path or a filename."""
        return makelatexUtil.stripExten(makelatexUtil.fileOnly(path))
    @staticmethod
    def stripExten(filename, exten=None):
        """Strips everything after that last '.' in the filename. If exten is
        set to a string (or a list of strings) and the filename ends
        with that string, we will remove that string from the
        filename. Returns the result.
        """
        if exten:
            if type(exten) == str:
                if filename.endswith(exten):
                    return filename[:-len(exten)]
            elif type(exten) == list:
                for e in exten:
                    if filename.endswith(e):
                        return filename[:-len(e)]
            return filename
        else:
            return filename.rsplit('.', 1)[0]
    @staticmethod
    def changeExten(filename, orig, new):
        """Remove extension orig (if it exists) on filename and adds extension new."""
        return makelatexUtil.stripExten(filename,orig)+new
    @staticmethod
    def removeIfExist(filename):
        """Removes a file if it exists."""
        if os.path.exists(filename):
            os.remove(filename)
    @staticmethod
    def printError(msg):
        """Prints a highlighted error message to stdout."""
        print(makelatexUtil.getErrorColorCode() + msg + makelatexUtil.getResetColorCode())
    @staticmethod
    def printWarn(msg):
        """Prints a highlighted warning message to stdout."""
        print(makelatexUtil.getWarnColorCode() + msg + makelatexUtil.getResetColorCode())
    @staticmethod
    def getWarnColorCode():
        return '\033[93m\033[1m'  # yellow, bold
    @staticmethod
    def getErrorColorCode():
        return '\033[91m\033[1m'  # red, bold
    @staticmethod
    def getResetColorCode():
        return '\033[0m'  # reset
    @staticmethod
    def getEnviron(name):
        """Gets an environment variable. Returns an empty string if variable is
        not set"""
        if name in os.environ:
            return os.environ[name]
        else:
            return ""
    @staticmethod
    def filesMatchingRegex(regex, dir=None):
        """Given a directory, returns the list of files in the directory that match the provided regular expression.  Not recursive."""
        if not dir:
            dir = os.getcwd()
        ret = []

        for f in os.listdir(dir):

            # skip non-tex files
            if not f.endswith(".tex"):
                continue

            # Try opening file
            try:
                for line in open(f):
                    if line and re.match(regex, line):
                        if ret.count(f) == 0:
                            ret.append(f)

            except IOError: # occurs if file isn't readable or for directories
                pass

        ret.sort()
        return ret


import string, subprocess, os, sys, shutil, time
class uconvert:
    """A class that supports universal conversion between different file types."""

    # This program attempts to create the requested files using a
    # variety of conversions rules (i.e., programs to run) hardcoded
    # in the processfiles() function.
    VERBOSE=1
    DEST_DIR=""  # Where should the files that we create go?
    SRC_DIR=""   # Where should we look for source files to create our converted file from?


    def runcommand(self, command, inexten, outexten, base, indir, outdir):
        """If a suitable conversion has been found, runcommand() runs the
        conversion command. An appropriate source file should exist
        before calling runcommand().

        command:  The command to run
        inexten:  The extension of the source file
        outexten: The requested file extension
        base:     The basename of the file (source and destination)
        indir:    The directory where the file can be found
        outdir:   The location where the output file should be created
        """

        # Note that base can have a directory as a part of it.  We will change
        # into that directory though...so strip it off here.
        command = command.replace("BASE", str.split(base, "/")[-1])
        command = command.replace("IN",   inexten)
        command = command.replace("OUT",  outexten)

        # Store the complete paths to the files
        filein = indir  + "/" + base + "." + inexten
        fileout = outdir + "/" + base + "." + outexten

        # Ensure that the source file exists.
        if not os.path.exists(filein):
            self.printError("uconvert: ERROR: You called runcommand() with an nonexistant input file")
            return False # fail

        fileinstat  = os.stat(filein)

        # create output directory if it doesn't exist
        if not os.path.exists(os.path.dirname(outdir + "/" + base)):
            os.makedirs(os.path.dirname(outdir + "/" + base))

        # if output file already exists, check if we need to regenerate it (by
        # looking at modification time)
        if os.path.exists(fileout):
            fileoutstat = os.stat(fileout)

            if fileinstat.st_mtime <= fileoutstat.st_mtime:
                if self.VERBOSE >= 2:
                    print("uconvert: " + base+"."+outexten+" ("+makelatexUtil.humanSize(fileoutstat.st_size)+"): No update needed.")
                    sys.stdout.flush()
                return True # success

        ruleName = command.split(" ")[0]
        if not makelatexUtil.findFileInPaths(command.split(" ")[0]):
            print("uconvert: Skipping rule because \"" + ruleName + "\" is not available; trying other rules...")
            return False


        # Run the command in the directory of the source file
        command = "cd " + os.path.dirname(indir+"/"+base) + " && " + command
        if self.VERBOSE >= 3: print(command)

        # Run the command
        if subprocess.call(["/usr/bin/env", "bash", "-c", command]) == 0:
            # ... if the command returned a normal return value....

            # check if output file was created (it should be in the same
            # directory as the input file)
            if os.path.exists(indir + "/" + base + "." + outexten):

                # move the file we made into the output directory
                shutil.move( indir+"/"+base+"."+outexten, fileout )

                # get size information on our new file
                fileoutstat = os.stat(fileout)

                # Print the filenames of what we converted...not the paths
                print("uconvert: " + base+"."+outexten +" ("+makelatexUtil.humanSize(fileoutstat.st_size)+") <-- " + base+"."+inexten+" ("+makelatexUtil.humanSize(fileinstat.st_size)+") using " + ruleName)
                sys.stdout.flush()
                return True  # success

            else:  # program ran properly, but the output file wasn't created
                self.printError("uconvert: ERROR " + fileout + ": Running command didn't create file! Command: " + command)
                sys.stdout.flush()
                return False # fail
        else:
            self.printError("uconvert: ERROR: " + fileout + ": Command failed: " + command)
            sys.stdout.flush()
            return False  # program failed



    def convertfile(self, inlist, outlist, command, request):
        """Tries to run the given rule to create the requested file (request). A rule is a list of input file extensions (inlist), a list of output file extensions (outlist), and a command that converts the file. Returns true if successful."""

        requestBase  = request.rsplit(".", 1)[0]
        requestExten = request.rsplit(".", 1)[1]

        for path in self.SRC_DIR: # for all paths
            # If the output is a different directory than the source directory and
            # the requested file is already in the source directory, just copy it
            # over!

            if self.DEST_DIR != path and os.path.exists(path + "/" + request):

                # create output directory
                try:
                    os.makedirs(os.path.dirname(self.DEST_DIR + "/" + request))
                except OSError:
                    # directory already exists or we can't create
                    # it. Some other thread may have created the path
                    # for us.
                    pass

                shutil.copy(path + "/" + request,
                            self.DEST_DIR + "/" + request)
                makelatexUtil.updateMtime(path + "/" + request,
                            self.DEST_DIR + "/" + request)

                if self.VERBOSE >= 2:
                    print("uconvert: Copy  " + request + ": Copied to destination.")
                return True # success


        if requestExten in outlist:  # if our requested extension can be output
            for item in inlist:      # for all of the input extensions
                for path in self.SRC_DIR: # and for all paths
                    if item != requestExten:  # if the source and requested extension are different
                        # and if the source file exists
                        if os.path.exists(path + "/" + requestBase + "." + item):
                            ret = self.runcommand(command, item, requestExten, requestBase, path, self.DEST_DIR)
                            if ret == True:
                                makelatexUtil.updateMtime(path + "/" + requestBase + "." + item,
                                            self.DEST_DIR + "/" + request)
                                return True


        return False # fail





    def processFile(self, arg):
        """arg is a file that we want to create. This function attempts to find a conversion rule (and a source file) that we can use to create requested file."""

        convertRules = [ [ "svg svgz", 
                          "eps", 
                          "inkscape -D --without-gui --export-text-to-path --file=\"BASE.IN\" --export-eps=\"BASE.OUT\"" ],
                        [ "svg svgz", 
                          "ps",
                          "inkscape -D --without-gui --file=\"BASE.IN\" --export-ps=\"BASE.OUT\"" ],
                        [ "svg svgz",
                          "pdf",
                          "inkscape -D --without-gui --export-text-to-path --file=\"BASE.IN\" --export-pdf=\"BASE.OUT\" && ps2pdf \"BASE.OUT\" \"BASE.OUT\".tmp && mv \"BASE.OUT\".tmp \"BASE.OUT\"" ],
                        [ "svg svgz", 
                          "png",
                          "inkscape -D --without-gui --file=\"BASE.IN\" --export-png=\"BASE.OUT\"" ],
                        [ "dvi",
                          "ps",
                          "dvips -o \"BASE.OUT\" \"BASE.IN\"" ],
                        [ "dvi",
                          "pdf",
                          "dvipdf \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "dvi",
                          "png", 
                          "dvipng -pp 1 -f \"BASE.OUT\" \"BASE.IN\"" ],
                        [ "dvi",
                          "gif", 
                          "dvigif -pp 1 -f \"BASE.OUT\" \"BASE.IN\"" ],
                        [ "ps",
                          "pdf",
                          "ps2pdf -dPDFSETTINGS=/prepress \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "eps",
                          "pdf",
                          "ps2pdf -dPDFSETTINGS=/prepress -dEPSCrop \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "ps.gz",
                          "pdf",
                          "gunzip -c \"BASE.IN\" | ps2pdf - \"BASE.OUT\"" ],
                        [ "pdf",
                          "ps",
                          "pdftops -level3 \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "pdf",
                          "eps",
                          "pdftops -level3 -eps \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "fig",
                          "eps",
                          "fig2dev -L eps \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "fig",
                          "bmp gif ico png pnm ppm tiff tif xcf rgb rgba jp2 jpeg jpg",
                          "fig2dev -L eps \"BASE.IN\" | convert -density 300 - \"BASE.OUT\"" ],
                        [ "fig",
                          "mps",
                          "fig2dev -L mp \"BASE.IN\" \"BASE.mp\" && mpost \"BASE.mp\" &> /dev/null && rm -f \"BASE.log\" \"BASE.mpx\" && mv \"BASE.0\" \"BASE.OUT\"" ],
                        [ "mp",
                          "mps ps",
                          "mpost \"BASE.mp\" &> /dev/null && rm -f \"BASE.log\" \"BASE.mpx\" && mv \"BASE.0\" \"BASE.OUT\"" ],
                        [ "svg",
                          "png",
                          "rsvg-convert --keep-aspect-ratio --zoom=4 \"BASE.IN\" --output \"BASE.OUT\"" ],
                        [ "svg",
                          "jpg",
                          "rsvg-convert --keep-aspect-ratio --zoom=4 \"BASE.IN\" --output \"BASE.OUT\"" ],
                        [ "svg",
                          "pdf",
                          "rsvg-convert --format pdf \"BASE.IN\" --output \"BASE.OUT\"" ],
                        [ "eps ps svg svgz pdf wmf bmp gif ico png pnm ppm tga tiff tif xcf rgb rgba jp2 jpeg jpg",
                          "ps svg svgz pdf wmf bmp gif ico png pnm ppm tga tiff tif xcf rgb rgba jp2 jpeg jpg",
                          "convert -density 300 \"BASE.IN\" \"BASE.OUT\"" ],
                        [ "png tiff tif bmp rgb",
                          "eps",
                          "convert \"BASE.IN\" \"eps3:BASE.OUT\"" ],
                        [ "jpg jpeg",
                          "eps",
                          "convert \"BASE.IN\" \"eps2:BASE.OUT\"" ],
                        [ "eps ps svg svgz pdf wmf bmp gif ico png pnm ppm tga tiff tif xcf rgb rgba jp2 jpeg jpg",
                          "eps ps svg svgz pdf wmf bmp gif ico png pnm ppm tga tiff tif xcf rgb rgba jp2 jpeg jpg",
                          "gm convert -density 300 \"BASE.IN\" \"BASE.OUT\"" ]]
        success = 0;
        for convertRule in convertRules:
            if success == 0 and self.convertfile(convertRule[0].split(),
                                                 convertRule[1].split(),
                                                 convertRule[2], arg):
                success = 1

        if success == 0:
            if os.path.exists(arg):
                if self.VERBOSE >= 1:
                    makelatexUtil.printWarn("uconvert WARNING: \"" + arg + "\" exists, but can't find file it was created from.")
            else:
                makelatexUtil.printError("uconvert ERROR: Missing source file or a conversion rule to create \"" + arg + "\".")
            return False
        return True

    def __init__(self, verbose=1, srcdir=None, destdir=None):
        """Create a uconvert object.

        verbose: 0=only errors; 1=error+warn; 2=more info; 3=everything
        srcdir: colon-sepeated list of paths to look for source material to convert from.
        destdir: path where converted files are saved."""
        self.VERBOSE=verbose
        self.DEST_DIR=destdir
        self.SRC_DIR=srcdir

        if self.DEST_DIR and len(self.DEST_DIR) != 0:
            if self.VERBOSE >= 2:
                print("uconvert: Putting output files in: " + self.DEST_DIR)
        else:
            self.DEST_DIR="."
            if self.VERBOSE >= 2:
                print("uconvert: Putting output files in current directory.")

        if self.SRC_DIR and len(self.SRC_DIR) != 0:
            self.SRC_DIR = str.split(self.SRC_DIR,  ":")
            if self.VERBOSE >= 2:
                print("uconvert: Looking for source files in: " + str(self.SRC_DIR))
        else:
            self.SRC_DIR = [ "." ]  # just use the current directory
            if self.VERBOSE >= 2:
                print("uconvert: Looking for source file in current directory.")


import subprocess, os, sys, shutil, argparse, re, time, atexit
import threading, traceback
class makelatex:
    MLTMP = "makelatex-tmp/"

    # used by both latex and pdflatex
    LATEX_ARGS = "-file-line-error -interaction=nonstopmode -output-directory="+MLTMP
    DVIPS_ARGS = "-Ppdf -G0"
    PDFNUP_ARGS = "--frame true --keepinfo --quiet"
    # We automatically select a papersize for pdfnup that matches the input
    # PDF. If the input is neither "a4paper" or "letterpaper", we will use the
    # following:
    PDFNUP_PAPER = "letterpaper"

    # PS2PDF argument documentation:
    # http://pages.cs.wisc.edu/~ghost/doc/cvs/Ps2pdf.htm
    # http://ghostscript.com/doc/current/Ps2pdf.htm
    # -dPDFA = creates PDF/A documents

    # The following arguments request lossy compression for images. If we
    # use lualatex (which uses lossy compression on JPEG images), using
    # lossless encoding with ps2pdf on a file created by lualatex will
    # produce in large files and no increase in image quality.
    PS2PDF_ARGS = " -dPDFSETTINGS=/prepress " \
        "-dAutoRotatePages=/None " \
        "-dEmbedAllFonts=true " \
        "-dMaxSubsetPct=100 " \
        "-dSubsetFonts=true " \
        "-dAutoFilterColorImages=false " \
        "-dAutoFilterGrayImages=false " \
        "-dDownsampleColorImages=false " \
        "-dDownsampleGrayImages=false " \
        "-dDownsampleMonoImages=false "

    ## The following will force lossless image encoding (even if the input to
    ## PS2PDF is already using lossy encoding).
    # PS2PDF_ARGS = PS2PDF_ARGS \
    #     "-dColorImageFilter=/FlateEncode" \
    #     "-dGrayImageFilter=/FlateEncode" \
    #     "-dMonoImageFilter=/FlateEncode"

    # ColorConversionStrategy option is used to hide a warning related to sRGB
    # (noticed on Ubuntu 12.10, ghostscript 9.06)
    PS2PDF_ARGS_SCREEN = " -dPDFSETTINGS=/screen " \
        "-dColorConversionStrategy=/LeaveColorUnchanged" \
        "-dAutoRotatePages=/None " \
        "-dEmbedAllFonts=true " \
        "-dMaxSubsetPct=100 " \
        "-dSubsetFonts=true " \
        "-dColorImageResolution=150 " \
        "-dGrayImageResolution=150 " \
        "-dMonoImageResolution=300 "


    lockfile = ".makelatex.lock"
    outfmt = '%20s: %s'
    tmpUconvertDir = MLTMP + "uconvert"
    makelatex_start_time = time.time()
    
    # requestedOptimize helps determine if we need to print a message about
    # optimization when we exit from --loop or -l mode:
    requestedOptimize = False

    args=[]

    def __init__(self, inputArgs=None):
        """Parses arguments, puts tex files to compile in args.texfiles variable. Doesn't actually compile any LaTeX documents."""

        self.makelatex_start_time = time.time()
        self.parseArguments(inputArgs)
        self.initialSetupGetEngine()

        if self.args.diff:
            if makelatexUtil.findFileInPaths("latexdiff"):
                # allow users to specify basename, pdf, or tex file...change it to .tex file:
                self.args.diff[0] = makelatexUtil.stripExten(self.args.diff[0], [".pdf", ".tex"]) + ".tex"
                self.args.diff[1] = makelatexUtil.stripExten(self.args.diff[1], [".pdf", ".tex"]) + ".tex"

                if os.path.exists(self.args.diff[0]) and os.path.exists(self.args.diff[1]):
                    self.runCommand("latexdiff", self.args.diff[0] + " " + self.args.diff[1] + " > makelatex-diff.tex", shell=True)
                    self.args.texfiles.append("makelatex-diff.tex")
                else:
                    makelatexUtil.printError("One of the tex files used with --diff does not exist: " + self.args.diff[0] + " " +self.args.diff[1])
                    exit(1)
            else:
                makelatexUtil.printError("latexdiff is not installed.")
                exit(1)

        if self.args.synctex:
            self.LATEX_ARGS = self.LATEX_ARGS + " -synctex=1"
            # NOTE: I don't think plain "latex" supports synctex, but it doesn't
            # hurt to try to use it if the user requested it.

        # Optimizing the PDFs takes some time.
        # If user is running in loop mode, they probably
        # want immediate feedback---not small file sizes
        if self.args.loop and self.args.optimize:
            print("NOTE: Optimization is disabled in loop mode.")
            self.args.optimize=False
            # use the following to print message when we exit out of loop:
            self.requestedOptimize=True

        if not self.args.clean:
            # Make a temporary directory to store stuff
            try:
                os.mkdir(self.MLTMP)
            except OSError: # directory already exists
                pass

        # Sometimes we run programs in the makelatex-tmp directory and we need
        # them to see the files in the actual directory.
        os.environ['TEXINPUTS'] = os.getcwd() + os.pathsep + makelatexUtil.getEnviron('TEXINPUTS')
        os.environ['BIBINPUTS'] = os.getcwd() + os.pathsep + makelatexUtil.getEnviron('BIBINPUTS')
        # Needed if a .bst file is in the same directory as the paper.
        os.environ['BSTINPUTS'] = os.getcwd() + os.pathsep + makelatexUtil.getEnviron('BSTINPUTS')

        # Check for uconvert in our current directory.
        os.environ['PATH'] = makelatexUtil.getEnviron('PATH')+os.pathsep+os.getcwd()

        # We don't want to know about makelatex-tmp/uconvert when determining
        # dependencies---we want to depend on the original files.
        os.environ['TEXINPUTS_NOTMP'] = makelatexUtil.getEnviron("TEXINPUTS")
        # LaTeX needs to know about makelatex-tmp/uconvert:
        if not os.environ['TEXINPUTS'].startswith(self.MLTMP+"uconvert:"):
            os.environ['TEXINPUTS']=self.MLTMP+"uconvert:" + makelatexUtil.getEnviron('TEXINPUTS')

        if os.path.exists(self.lockfile):
            print("Is this script running elsewhere? If not,")
            print("delete " + self.lockfile + " and try again.")
            exit(1)


    def parseArguments(self, inputArgs=None):
        if inputArgs==None:
            self.args = sys.argv
        else:
            self.args = inputArgs

        parser = argparse.ArgumentParser(description='Build PDF files from LaTeX files.')

        parser.add_argument('texfiles', metavar='X.tex', type=str, nargs='*',
                            help='One or more tex files, if none provided, we will guess.')
        parser.add_argument('-f', '--force', action="store_true",
                            help='Recreate pdf even if one already exists')
        parser.add_argument('-o', '--optimize',  action="store_true",
                            help='Linearize PDF with qpdf or pdfopt')

        # TODO: Threading is disabled by default since there we sometimes have one
        # thread hang on a subprocess.call() which causes us to hang. Once
        # threading works reliably, we should change this to --nothreads.
        parser.add_argument('-t', '--threads',  action="store_true",
                            help='Compile each document in its own thread.')

        parser.add_argument('--noconvert',  action="store_true",
                            help='Don\'t automatically convert images')
        parser.add_argument('-l', '--loop', action="store_true",
                            help='Make repeatedly')
        parser.add_argument('-k', '--keep', action="store_true",
                            help='Keep makelatex-tmp folder containing logs and converted images')
        parser.add_argument('-c', '--clean', action="store_true",
                            help='Just cleanup, don\'t build tex files')
        # In the "help" variable below, "%%" is needed before !TEX for help information to be displayed...
        parser.add_argument('-e', '--engine',
                            help="latex (uses dvips and ps2pdf), pdflatex, xelatex, or lualatex. You can also set this with the MAKELATEX_ENGINE environment variable or with a '%%!TEX program=enginename' in the first line of your latex file.")
        # Default to synctex ON
        #parser.add_argument('-s', '--synctex', action="store_false",
        #                    help="Use synctex (your editor must support it)")
        # Default to synctex OFF
        parser.add_argument('-s', '--synctex', action="store_true",
                            help="Use synctex (your editor must support it)")
        # Overview of synctex: http://www.tug.org/TUGboat/tb29-3/tb93laurens.pdf
        # Can be enabled in documents with \synctex=1
        # evince 2.32 supports synctex through Ctrl+LeftClick
        # gedit supports it through a plugin
        # Emacs supports it with some help: http://www.emacswiki.org/emacs/AUCTeX
        # pdflatex and xelatex supports it since TexLive 2008

        parser.add_argument('--nupLand', metavar="NxN",
                            help="2x1 (2 pages per 1 landscape page, side by side); 1x2 (above/below); etc")
        parser.add_argument('--nupPort', metavar="NxN",
                            help="2x1 (2 pages per 1 portrait page, side by side); 1x2 (above/below); etc")
        parser.add_argument('--nupHandout', action="store_true",
                            help="3 pages per page with room for notes (useful for presentations)")
        # Disable greyscale rendering, see explanation near greyscalePdf():
        # parser.add_argument('--greyscale', '--grayscale', action="store_true",
        #                    help="Convert output pdf to greyscale.")
        parser.add_argument('--screen', action="store_true",
                            help="Compress images in PDF more heavily (reduce image resolution, use lossy image compression)")
        parser.add_argument('--nonascii', action="store_true",
                            help="Warn about non-ASCII characters in tex files.")
        parser.add_argument('--quiet', '-q', action="store_true",
                            help="Turns on --nonascii. Also hides other output except for warnings/errors and PDF statistics.")
        parser.add_argument('--diff', nargs=2, metavar=('old.tex', 'new.tex'),
                            help="Generates a PDF showing differences between two versions of a document (requires latexdiff command).")

        self.args = parser.parse_args()
        # LuaTex and XeLaTeX should be able to handle Unicode characters fine.
        if self.args.engine == "pdflatex" or self.args.engine == "latex":
            self.args.nonascii = True



    def makeSuggestions(self, texfiles):
        """Runs chktex and lacheck (if they are installed) to make
        suggestions to the user. Also puts the output of diction, style, and
        texcount in makelatex-tmp directory (if they are installed)."""
        if self.args.quiet:
            return

        # Change list of texfiles to filename only (not full path):
        filenames = map(makelatexUtil.fileOnly, texfiles)

        for i in filenames:
            logfile = self.MLTMP+"texcount-"+i+".log"
            makelatexUtil.removeIfExist(logfile)
            self.runCommand("texcount", i + " > " + logfile, shell=True, silentFail=True)

            logfile = self.MLTMP+"diction-"+i+".log"
            makelatexUtil.removeIfExist(logfile)
            self.runCommand("diction", i + " > " + logfile, shell=True, silentFail=True)

            logfile = self.MLTMP+"style-"+i+".log"
            makelatexUtil.removeIfExist(logfile)
            self.runCommand("style", makelatexUtil.fileOnly(i) + " > " + logfile, shell=True, silentFail=True)

        for i in filenames:
            # chktex
            i = makelatexUtil.bname(i)
            logfile = self.MLTMP+"chktex-"+i+".log"
            makelatexUtil.removeIfExist(logfile)
            self.runCommand("chktex", [ "-q", "-v3", "-o", logfile, i ], shell=False, silentFail=True)
            if os.path.exists(logfile):
                count = open(logfile).read().count(', line')
                if count > 0:
                    issue = "issues"
                    if(count == 1):
                        issue = "issue"
                    makelatexUtil.printWarn(self.outfmt % (i, "chktex found " + str(count) + " " + issue + ". Run \"chktex " + i + "\""))

            # lacheck
            logfile = self.MLTMP+"lacheck-"+i+".log"
            self.runCommand("lacheck", i + " > " + logfile, shell=True, silentFail=True)
            if os.path.exists(logfile):
                count = open(logfile).read().count(', line')
                if count > 0:
                    issue = "issues"
                    if(count == 1):
                        issue = "issue"
                    makelatexUtil.printWarn(self.outfmt % (i, "lacheck found " + str(count) + " " + issue + ". Run \"lacheck " + i + "\""))

        # bibcheck
        depend = []
        for i in filenames:
            depend.extend(self.findPotentialDependencies(i))
        depend = makelatexUtil.dedup(depend)
        for d in depend:
            if d.endswith(".bib"):
                logfile = self.MLTMP+"bibcheck-"+makelatexUtil.bname(d)+".log"
                self.runCommand("bibcheck", d + " > " + logfile, shell=True, silentFail=True)
                if os.path.exists(logfile) and len(open(logfile).read()):
                    count = open(logfile).read().count(d+":")
                    if count > 0:
                        issue = "issues"
                        if(count == 1):
                            issue = "issue"
                        makelatexUtil.printWarn("bibcheck found " + str(count) + " " + issue + ". To view, run \"bibcheck " + makelatexUtil.bname(d) + "\"")



    def getTexFiles(self):
        """Get list of tex files for us to process based on the arguments
        provided. If no arguments are provided, then we will find appropriate
        .tex file(s). All of the filenames returned will have a .tex
        ending---even if the user provided arguments that ended in .pdf"""

        # if there are no arguments, find matching tex files
        if not self.args.texfiles:
            texs = makelatexUtil.filesMatchingRegex('^[^%]*\\\\begin{document}')
        else:
            texs = []
            for i in self.args.texfiles:
                if i.endswith(".tex") and os.path.exists(i): # we want .tex endings
                    texs.append(i)
                # if we got .pdf ending and .tex file exists with same name, change argument:
                elif i.endswith(".pdf") and os.path.exists(i[:-4]+".tex"):
                    texs.append(i[:-4]+".tex")
                # if nothing above worked, try adding .tex to the end
                elif os.path.exists(i + ".tex"):
                    texs.append(i+".tex")
                else:
                    makelatexUtil.printError("ERROR: Can't find .tex file corresponding to: "+i)
                    exit(1)

        newtexs = []
        for t in texs:
            newtexs.append(makelatexUtil.findFileInPaths(t, makelatexUtil.getEnviron('TEXINPUTS')))

        texs = makelatexUtil.dedup(newtexs)


        # texs contains the files that we want to try to use.  We will put our final
        # list back into args.texfiles

        # There are dependencies if A.tex used \includepdf{B} and we are going
        # to create B.pdf.  In this case, we want to process B before A:

        # Loop is needed to sort out multiple levels of dependencies
        for numLoops in range(5):
            # Go through list of tex files in order. Find their dependencies
            # and make sure that we appear after them in the texfile list.
            newList = []
            for t in texs:
                deps = self.findPotentialDependencies(t)
                for d in deps:
                    # If t depends on a PDF, and we are building a .tex file
                    # with the same name.
                    pdfToTex = makelatexUtil.stripExten(d)+".tex"
                    if d.endswith(".pdf") and texs.count(makelatexUtil.stripExten(d)+".tex"):
                        # Don't use threading if there was a dependency
                        if self.args.threads == True:
                            self.args.threads = False
                            print("NOTE: Disabling threading since " + t + " depends on " + d)
                        # Add the tex file we depend on to the list (before adding t)
                        if newList.count(pdfToTex) == 0:
                            newList.append(pdfToTex)
                # Add this tex file to the list
                if not newList.count(t):
                    newList.append(t)

            # if list is unchanged through loop, we
            # successfully figured out the dependencies
            if newList == texs:
                self.args.texfiles = texs
                return texs
            else:
                texs = newList


        # If we got here, we couldn't sort out the
        # dependencies...oh well...
        self.args.texfiles = texs
        return texs





    def initialSetupGetEngine(self):
        """Sets self.args.engine to the name of the engine to use based on what is
        installed or what is in self.args.engine originally."""

        # If engine is not selected, but environment variable is set:
        if not self.args.engine and len(makelatexUtil.getEnviron("MAKELATEX_ENGINE")):
            self.args.engine = makelatexUtil.getEnviron('MAKELATEX_ENGINE')

        # If engine is not selected, pick one based on what is installed.
        if not self.args.engine:
            if makelatexUtil.findFileInPaths("xelatex", makelatexUtil.getEnviron('PATH')):
                self.args.engine = "xelatex"
            elif makelatexUtil.findFileInPaths("lualatex", makelatexUtil.getEnviron('PATH')):
                self.args.engine = "lualatex"
            elif makelatexUtil.findFileInPaths("pdflatex", makelatexUtil.getEnviron('PATH')):
                self.args.engine = "pdflatex"
            else: # fallback to latex
                self.args.engine = "latex"

        # Allowed engines and their actual values:
        engines = { "xelatex"  : "xelatex",
                    "xetex"    : "xelatex",
                    "x"        : "xelatex",
                    "pdflatex" : "pdflatex",
                    "pdf"      : "pdflatex",
                    "latex"    : "latex",
                    "dvips"    : "latex",
                    "lua"      : "lualatex",
                    "lualatex" : "lualatex",
                    "luatex"   : "lualatex" }
        try:
            self.args.engine = engines[self.args.engine]
        except KeyError:
            makelatexUtil.printError("ERROR: Unknown engine selected: " + self.args.engine)
            exit(1)

        # Verify that whatever engine was selected actually exists:
        if not makelatexUtil.findFileInPaths(self.args.engine):
            makelatexUtil.printError("ERROR: The " + self.args.engine + " engine was selected but binary does not exist in your PATH")
            exit(1)

        if self.args.engine == "latex":
            if not makelatexUtil.findFileInPaths("dvips"):
                makelatexUtil.printError("ERROR: The dvips command is required by makelatex if you are using the latex engine. It was not found in your PATH.")
                exit(1)
            if not makelatexUtil.findFileInPaths("ps2pdf"):
                makelatexUtil.printError("ERROR: The ps2pdf command is required by makelatex if you are using the latex engine. It was not found in your PATH.")
                exit(1)






    # Returns true if an update is forced or if the PDF file is older than one
    # (or more) files that it depends on.
    def isUpdateNeeded(self, tex):
        pdf = makelatexUtil.changeExten(tex, ".tex", ".pdf")

        if self.args.force or not os.path.exists(pdf):
            return True

        # Find potential dependencies (at minimum, returns tex file!)
        deps = self.findPotentialDependencies(tex)

        # Check if anything has been modified since we made the pdf
        pdfmtime = os.stat(pdf).st_mtime

        ret = False
    #    print "mtime of " + pdf + " is " + str("%.10f" % pdfmtime)
        for d in deps:
            # All of the dependencies should exist by the time we get here.
            # But, a user removing a file shouldn't cause us to try to
            # recompile the PDF and overwrite a good one that already exists.
            if not os.path.exists(d):
                continue
            # Except for the case above, all items in the
            # dependency list should actually exist because
            # we don't include things in the list that do not
            # exist.
            if os.stat(d).st_mtime > pdfmtime:
    #            print "mtime of dep " + d + " is " + str("%.10f" % os.stat(d).st_mtime)
                if not self.args.quiet: print(self.outfmt % (makelatexUtil.bname(tex), makelatexUtil.fileOnly(d) + " changed; rebuilding..."))
                ret = True

        return ret


    def runLatex(self, basename, exe=None):
        """Runs latex/pdflatex/xelatex/etc, returns true if successful if the command has an OK return value and if the command created the appropriate file (dvi for latex, pdf for pdflatex/etc.).  The resulting file will be put inside of the current directory (even though the arguments we pass to latex will initially create the file inside of the makelatex-tmp directory."""
        if not exe:
            exe = self.args.engine
        line = open(basename+".tex").readline()
        match = re.search(r"%\s*!TEX\s+program\s*=\s*(.*)",line)
        if match:
            exe = match.group(1)
            if not makelatexUtil.findFileInPaths(exe):
                makelatexUtil.printError("A !TEX directive told us to use the " + exe + " engine---but it is not in your PATH.")
                exit(1)

        if not self.args.quiet:
            print(self.outfmt % (basename, exe))
        command = exe + " " + self.LATEX_ARGS + " " + basename + " > " + self.MLTMP+"latex-"+basename+".log"

        if subprocess.call(['/bin/sh', '-c', command]) != 0:
            return False

        # Move the PDF (or DVI) out of the temporary directory and
        # back into the original directory the user expects it to
        # be. If we are using the plain "latex" command, the DVI will
        # get converted to a PDF later.
        dvi = basename+".dvi"
        pdf = basename+".pdf"
        if exe == "latex" and os.path.exists(self.MLTMP + dvi):
            shutil.move(self.MLTMP + dvi, dvi)
        elif os.path.exists(self.MLTMP + pdf):
            shutil.move(self.MLTMP + pdf, pdf)

        # Move the synctex file back to where the user expects it too.
        synctex = basename + ".synctex.gz"
        if self.args.synctex and os.path.exists(self.MLTMP + synctex):
            shutil.move(self.MLTMP + synctex, synctex)
        else:
            makelatexUtil.removeIfExist(synctex)

        return True


    def runCommand(self, exe, commandargs, shell=False, silentFail=False, wd=None):
        """Runs a command. If shell=True, commandargs is a string and the
        program is run in a shell. If shell=False, commandargs is a list of
        argument strings. If we can't find the exe, we either silently fail
        (and return None) or exit (with an error message)"""

        if not exe:
            makelatexUtil.printError("Internal error: runCommand() called with no exe.")
            exit(1)

        fullpath = makelatexUtil.findFileInPaths(exe)
        if fullpath == None:
            if silentFail:
                return None
            else:
                traceback.print_exc()
                makelatexUtil.printError("File \"" + exe + "\" not found in " + makelatexUtil.getEnviron('PATH'))
                exit(1)
        # rudimentary security for running as shell=True
        if shell and commandargs.count(";"):
            traceback.print_exc()
            makelatexUtil.printError("Arguments cannot contain a semicolon.")
            exit(1)

        if shell:
            ps = subprocess.Popen(exe + " " + commandargs, shell=True, cwd=wd)
        else:
            exe = [ exe ]
            exe.extend(commandargs)
            ps = subprocess.Popen(exe, cwd=wd)
        return ps.wait()


    def runDvips(self, basename):
        """Runs dvips and then ps2pdf to convert a dvi file into a pdf."""
        if self.args.engine != "latex":
            return True

        # NOTE: Some systems have a dvipdf script which converts from dvi to pdf,
        # but this is usually just a wrapper around dvips and gs

        dvi = basename+".dvi"
        ps = basename+".ps"

        if not os.path.exists(dvi):
            makelatexUtil.printError("ERROR: Can't run dvips because .dvi file doesn't exist.")
            return

        if not self.args.quiet:
            print(self.outfmt % (basename, "dvips"))

        if self.runCommand("dvips", "-f " + self.DVIPS_ARGS + " -o " + ps + " < " + dvi + " 2> " + self.MLTMP+"/dvips-" + basename + ".log", shell=True) != 0 or not os.path.exists(ps):
            self.printDvipsError(basename)
            makelatexUtil.printError("ERROR: dvips failed")
            return False
        makelatexUtil.removeIfExist(dvi)
        self.printDvipsError(basename)

        if not self.args.quiet: print(self.outfmt % (basename, "ps2pdf"))

        # Run ps2pdf with options that automatically rotate all pages one way
        # depending on text direction to make landscape pages work with "-e
        # latex"
        if not self.ps2pdf(self.PS2PDF_ARGS.replace("-dAutoRotatePages=/None",
                                                    "-dAutoRotatePages=/All"),
                           ps, basename + ".pdf", fast=True):
            makelatexUtil.printError("ERROR: Could not create PDF (is ps2pdf in PATH?).")
            return False
        makelatexUtil.removeIfExist(ps)
        return True


    def copyMetadata(self, src, dest):
        """Copies metadata from src PDF to dest PDF. Returns True if
        successful, False if failure."""

        if not os.path.exists(src) or not os.path.exists(dest):
            return False

        if src == dest:
            return True

        if not makelatexUtil.findFileInPaths("pdftk"):
            return False

        # ps2pdf does not copy metadata from the src pdf and adds some of its
        # own fields. If we wanted metadata to match exactly, we could clear
        # all metadata in dest and then copy it from src. However, if we remove
        # all metadata (by setting InfoValue: to blank in every entry), pdftk
        # will remove the Info dictionary entirely and refuse to add meta data
        # back in with a subsequent update_info.

        tmp = dest + ".tmp.pdf"

        # Copy metadata from src file into dest file (but store the resulting file in makelatex-tmp)
        self.runCommand("pdftk", src + " dump_data | pdftk " + dest + " update_info - output " + tmp, shell=True)

        if os.path.exists(tmp):
            shutil.move(tmp,dest)
            return True
        else:
            return False


    def cleanupEverything(self, texfiles=[]):
        """Removes PDFs, tmp directory, and all of the files that latex makes
        If texfiles is empty, we will not remove PDFs."""

        # remove the makelatex-tmp directory
        if os.path.exists(self.MLTMP):
            shutil.rmtree(self.MLTMP)

        # Everything gets put into the makelatex-tmp directory except for the
        # following which sometimes get created:
        makelatexUtil.removeIfExist("missfont.log")
        makelatexUtil.removeIfExist("texput.log")

        # This is created by us if --diff option is used:
        makelatexUtil.removeIfExist("makelatex-diff.tex")

        for texfile in texfiles:
            basename = makelatexUtil.stripExten(texfile,".tex")

            # remove the PDF file and any stray dvi/ps files
            # that might still be around.
            # NOTE: We also remove some common nup pdfs
            extlist = ".pdf .dvi .ps .tmp.pdf .grey.pdf " \
                ".screen.pdf .handout.pdf " \
                ".2x1.pdf .1x2.pdf .3x1.pdf .1x3.pdf " \
                ".2x2.pdf .3x2.pdf .2x3.pdf .synctex.gz"
            for e in extlist.split():
                makelatexUtil.removeIfExist(basename+e)

    def getPdfStats(self, path):
        """Returns a dictionary structure containing information about the
        given PDF."""
        if not os.path.exists(path) or not path.endswith(".pdf"):
            return None
        if not makelatexUtil.findFileInPaths("pdfinfo") or not makelatexUtil.findFileInPaths("pdffonts"):
            return None

        # Collect information from pdfinfo and pdffonts, store
        # information in log files that we'll use later.
        pdfinfo =  self.MLTMP + "pdfinfo-" +makelatexUtil.bname(path)+".log"
        pdffonts = self.MLTMP + "pdffonts-"+makelatexUtil.bname(path)+".log"
        # Using fileOnly() on the path fixes a problem with running makelatex in cygwin
        self.runCommand("pdfinfo",  "\"" + makelatexUtil.fileOnly(path) + "\" > \"" + pdfinfo  + "\" 2>/dev/null", shell=True)
        self.runCommand("pdffonts", "\"" + makelatexUtil.fileOnly(path) + "\" > \"" + pdffonts + "\" 2>/dev/null", shell=True)

        # Print # of pages and paper size
        numPages = '?'
        pageSize = '?'
        fileSize = os.stat(path).st_size
        unembeddedFonts = 0
        nonSubsettedFonts = 0
        nonCompactFonts = 0
        type3Fonts = 0
        totalFonts = -1
        linear = False

        if self.findMatches([ "Optimized:(.*)yes" ], pdfinfo):
            linear = True

        for line in open(pdfinfo):
            if line.startswith("Pages:"):
                numPages = int(str(line[16:]).strip())
            if line.startswith("Page size:"):
                # use text in parenthesis if it is available
                tmp = str(line[16:]).strip()
                tmp = tmp.replace(" x ", "x")
                tmp = tmp.replace(" pts", "pts")
                if tmp.count("(") and tmp.count(")"):
                    tmp = tmp.replace("(", "")
                    tmp = tmp.replace(")", "")
                    pageSize = tmp.split(" ")[1] + " paper"
                else:
                    pageSize = tmp.split(" ")[0]


        pdfver = self.findMatches([ "PDF version:(.*)" ], pdfinfo)
        if pdfver[0]:
            pdfver = pdfver[0]
            pdfver = pdfver.strip()

        # Check for fonts that are not embedded or are bitmapped.
        lines = 0
        for line in open(pdffonts):
            lines += 1
        totalFonts = lines - 2

        for line in open(pdffonts):
            # Find column from end of line since some font names are really long:
            if line[-22:-19] == "no ":
                unembeddedFonts += 1
            if line[-18:-15] == "no ":
                nonSubsettedFonts += 1

        # Font types recognized by pdffonts: Type 1, Type 1C (i.e., Compact
        # Font Format, CFF), Type 3, TrueType, CID Type 0 (uncommon), CID Type
        # 0C (16 bit PostScript CFF font), CID TrueType.
        #
        # We are concerned with two different fonts:
        #
        # Type 3 - Usually bitmapped if they are coming out of LaTeX. Type 3
        # doesn't stictly mean bitmapped as described in the following URL:
        # http://tex.stackexchange.com/questions/18712/why-call-type-3-font-bitmap
        #
        # Type 1 - It is better to use a compact format, Type 1C

        # Type 3 fonts are usually bitmapped when using LaTeX. However, Type 3
        # doesn't necessarily mean that that the font is bitmapped:
        # http://tex.stackexchange.com/questions/18712/why-call-type-3-font-bitmap
        for line in open(pdffonts):
            if line[37:43] == "Type 3":
                type3Fonts += 1
        for line in open(pdffonts):
            if line[37:44] == "Type 1 ":
                nonCompactFonts += 1

        return { "filename": path,
                 "numPages": numPages,
                 "pageSize": pageSize,
                 "fileSize": fileSize,
                 "unembeddedFonts": unembeddedFonts,
                 "type3Fonts": type3Fonts,
                 "nonCompactFonts": nonCompactFonts,
                 "nonSubsettedFonts": nonSubsettedFonts,
                 "totalFonts": totalFonts,
                 "linear": linear,
                 "pdfversion": pdfver}

    def printPdfStats(self, stats):
        if not stats:
            return

        if stats['numPages'] == 1:
            bufferStr = "%2d %s" % (stats['numPages'], "pg;  ")
        else:
            bufferStr = "%2d %s" % (stats['numPages'], "pgs; ")

        bufferStr = bufferStr + makelatexUtil.humanSize(stats['fileSize']).rjust(6) + "; "
        bufferStr = bufferStr + stats['pageSize'] + "; "
        bufferStr = bufferStr + "PDFv" + stats['pdfversion']
        if stats['linear']:
            bufferStr = bufferStr + "(linear)"

        print(self.outfmt % (makelatexUtil.bname(stats['filename']), bufferStr))

        f = stats['totalFonts']
        if f > 0: bufferStr = str(f) + " font"
        if f > 1: bufferStr = bufferStr + "s"
        bufferStr = bufferStr+":"

        f = stats['unembeddedFonts']
        if f > 0: bufferStr = bufferStr + " " + str(f) + " unembedded,"
        f = stats['type3Fonts']
        if f > 0: bufferStr = bufferStr + " " + str(f) + " bitmapped,"
        f = stats['nonCompactFonts']
        if f > 0: bufferStr = bufferStr + " " + str(f) + " noncompact,"
        f = stats['nonSubsettedFonts']
        if f > 0: bufferStr = bufferStr + " " + str(f) + " nonsubsetted,"

        if stats['unembeddedFonts'] or stats['type3Fonts'] or stats['nonCompactFonts'] or stats['nonSubsettedFonts']:
            makelatexUtil.printWarn(self.outfmt % (makelatexUtil.bname(stats['filename']), bufferStr[0:-1]))


    def printPdfStatsPath(self, path):
        """Given a basename, print out statistics for any PDFs that we might have created."""

        extlist = ".pdf .grey.pdf .screen.pdf .handout.pdf .2x1.pdf .1x2.pdf .3x1.pdf .1x3.pdf .2x2.pdf .3x2.pdf .2x3.pdf"
        for e in extlist.split():
            filename = makelatexUtil.stripExten(path, ".pdf")+e
            stats = self.getPdfStats(filename)
            self.printPdfStats(stats)





    def ps2pdf(self, commandargs, infile, outfile, fast=False):
        """Calls ps2pdf, manages mtime properly, copies metadata from original file to new one. Returns true if outFile is created. Prints warning if metadata is not copied. If fast=False, we will try to embed fonts and linearize the PDF."""
        if not os.path.exists(infile):
            return False

        mtime = os.stat(infile).st_mtime
        command = commandargs.split()
        command.append(infile)
        command.append(outfile)

        if self.runCommand("ps2pdf", command, shell=False, silentFail=True) == None:
            # If ps2pdf doesn't appear to be installed, return false:
            return False

        if not os.path.exists(outfile):
            return False

        # If output file was created...

        # Copy metadata from original PDF into new one:
        if infile.endswith(".pdf"):
            if not self.copyMetadata(infile, outfile):
                makelatexUtil.printWarn(self.outfmt % (makelatexUtil.bname(infile), "Output PDF may have incorrect metadata. (Is pdftk installed?)"))

        # Embed fonts and linearize.
        if not fast:
            self.embedFonts(outfile)
            self.linearizePdf(outfile)

        os.utime(outfile, (mtime,mtime))
        return True


    def embedFonts(self, path):
        """Rebuild a PDF if it contains non-compact Type 1 fonts, fonts that
        are not subsetted, or fonts that are not embedded using ps2pdf. Output
        PDF is saved on top of the original."""
        infile = path
        outfile = makelatexUtil.stripExten(path,".pdf") + ".tmp.pdf"

        stats = self.getPdfStats(infile)
        if not stats or (stats['nonCompactFonts'] == 0 and stats['nonSubsettedFonts'] == 0 and stats['unembeddedFonts']==0):
            return False

        if not self.args.quiet:
            print(self.outfmt % (makelatexUtil.bname(path), "Compact, subset, and embed fonts."))

        # We don't embed/linearize here because we will optimize later...
        mtime = os.stat(infile).st_mtime
        if self.ps2pdf(self.PS2PDF_ARGS, infile, outfile, fast=True):
            shutil.move(outfile, infile)
            os.utime(infile, (mtime,mtime))
            return True

        return False

    # # This method of using pdf2ps and then ps2pdf to make the file greyscale
    # # works, reduces the PDF quality significantly.
    # #
    # # We used to convert to greyscale this way:
    # # http://superuser.com/questions/318586/how-to-convert-pdf-to-grayscale
    # # But it currently does not work because of this bug:
    # # http://bugs.ghostscript.com/show_bug.cgi?id=693074
    # def greyscalePdf(infile):
    #     """Make a greyscale PDF if the user requested it. Returns true if file
    #     is successfully created."""
    #     if not self.args.greyscale:
    #         return True

    #     mtime = os.stat(infile).st_mtime
    #     outfile = makelatexUtil.stripExten(infile,".pdf") + ".grey.pdf"
    #     psfile = makelatexUtil.stripExten(infile,".pdf") + ".grey.ps"
    #     if not self.args.quiet: print(self.outfmt % (makelatexUtil.bname(infile), "Converting to greyscale."))

    #     runCommand("pdf2ps", [ "-sDEVICE=psgray", infile, psfile ], shell=False, silentFail=False)
    #     ps2pdf(PS2PDF_ARGS, psfile, outfile, fast=False)
    #     makelatexUtil.removeIfExist(psfile)


    #     if os.path.exists(outfile):
    #         os.utime(outfile, (mtime,mtime))
    #         return True
    #     return False

    def screenPdf(self, infile):
        """Make a screen-quality PDF if the user requested it. Returns true if file
        is successfully created."""
        if not self.args.screen:
            return

        outfile = makelatexUtil.stripExten(infile,".pdf") + ".screen.pdf"
        if not self.args.quiet: print(self.outfmt % (makelatexUtil.bname(infile), "Creating screen-quality output."))
        if self.ps2pdf(self.PS2PDF_ARGS_SCREEN, infile, outfile, fast=False):
            # If we created a file that is larger than the original, 
            # forget about using it...
            if os.stat(infile).st_size < os.stat(outfile).st_size:
                shutil.copyfile(infile, outfile)

        return os.path.exists(outfile)



    def linearizePdf(self, path):
        """Linearizes the PDF with qpdf or pdfopt. Linearization allows people to
        view the PDF before it is completely downloaded."""
        orig = path
        opt = self.MLTMP + makelatexUtil.bname(path) + ".opt.pdf"

        if not makelatexUtil.findFileInPaths("qpdf") and not makelatexUtil.findFileInPaths("pdfopt"):
            makelatexUtil.printWarn("qpdf or pdfopt commands are necessary for PDF linearization.")
            return

        pdfstats = self.getPdfStats(orig)
        if not self.args.optimize or not pdfstats or pdfstats['linear']:
            return
        # a list of [ command, args ] for programs which linearize PDFs:
        options = [ [ "qpdf", [ "--linearize", orig, opt ] ],
                    [ "pdfopt", [ orig, opt ] ] ]

        for o in options:
            if makelatexUtil.findFileInPaths(o[0]):
                if not self.args.quiet: print(self.outfmt % (makelatexUtil.bname(path), "Optimize/linearize the PDF."))
                mtime = os.stat(orig).st_mtime
                self.runCommand(o[0], o[1], shell=False, silentFail=True)
                if os.path.exists(opt):
                    shutil.move(opt, orig)
                    os.utime(orig, (mtime,mtime))
                return

    def runMakeindex(self, basename):
        """Runs makeindex if needed. Returns True or False depending on if we
        had to run makeindex. Calls exit() when there is an error."""

        # a list of [ exten, command, args ]. Runs command+args when
        # basename.exen is present.
        options = [ [ ".idx", "makeindex", [ "-q", "-t", self.MLTMP+"makeindex-" + basename + ".log", self.MLTMP + basename + ".idx" ] ],
                    # nomencl.sty:
                    [ ".nlo", "makeindex", [ "-q", "-t", self.MLTMP+"makeindex-"+basename+".log", self.MLTMP + basename + ".nlo", "-s", "nomencl.ist", "-o", self.MLTMP + basename + ".nls" ] ] ]


        for o in options:
            if os.path.exists(self.MLTMP + basename + o[0]):
                if not self.args.quiet:
                    print(self.outfmt % (basename, o[1]))
                if not makelatexUtil.findFileInPaths("makeindex"):
                    makelatexUtil.printWarn("makeindex is not in PATH, index may be incorrect.")
                    return False
                if self.runCommand(o[1], o[2], shell=False, silentFail=False) != 0:
                    print(open(self.MLTMP + o[1]+basename+".log").read())
                    exit(1)
                return True
        return False



    def runMakeglossaries(self, basename):
        """Runs makeglossaries if needed. Returns True or False depending on if we
        had to run makeglossaries. Calls exit() when there is an error."""

        if not os.path.exists(self.MLTMP + basename + ".glo"):
            return False

        if not makelatexUtil.findFileInPaths("makeglossaries"):
            makelatexUtil.printWarn("makeglossaries is not in PATH, glossary may be incorrect.")
            return False


        if not self.args.quiet: print(self.outfmt % (basename, "makeglossaries"))

        if self.runCommand("makeglossaries", basename + "> makeglossaries-" + basename + ".log", shell=True, wd=self.MLTMP) != 0:
            print(open(self.MLTMP+"makeglossaries-" + basename + ".log").read())
            exit(1)

        return True

    def runBibtex(self, basename):
        """Runs bibtex if needed. Returns True or False depending on if we
        had to run bibtex. Calls exit() when there is an error."""

        # This message is put in the log file if we need to run bibtex:
        bibtexargs = self.findMatches( [ "^No file (.*)\.bbl" ], self.MLTMP+basename+".log")
        if len(bibtexargs) == 0:
            return False

        # Check if bibtex8 or bibtex is available somewhere in our path.
        exe = makelatexUtil.findFileInPaths("bibtex8")
        if not exe:
            exe = "bibtex"
        if not makelatexUtil.findFileInPaths(exe):
            makelatexUtil.printWarn("bibtex command is not in PATH, bibliography may be incorrect.")
            return False

        for basename in bibtexargs:
            if not self.args.quiet:
                print(self.outfmt % (basename, makelatexUtil.bname(exe)))

            # Run bibtex, look for errors problems.
            # bibtex8 returns 0 for OK run, 1 for warnings, 2 for errors
            # bibtex returns 0 for OK run/warnings, 2 for errors
            if self.runCommand(exe, basename + "> bibtex-" + basename+".log", shell=True, wd=self.MLTMP) > 1:
                # If bibtex doesn't run, print bibtex log file and exit:
                print(open(self.MLTMP+"bibtex-"+basename+".log").read())
                exit(1)

            else:  # If we ran bibtex successfully:
                for line in open(self.MLTMP+"bibtex-"+basename+".log"):
                    if line.startswith("Warning--") or line.startswith("Repeated entry---"):
                        print(makelatexUtil.getWarnColorCode() + basename+": "+ makelatexUtil.getResetColorCode() + line.strip())

        self.runPrePost("post-bibtex")

        return True


    def printLatexWarn(self, basename):
        """Analyzes the latex logs for the given file (given by its basename) and prints any errors/warnings to the console."""

        if os.path.exists(self.MLTMP+basename+".log"):
            with open(self.MLTMP+basename+".log") as f:
                lines = f.readlines()

            errMsg = [ "Missing character" ]
            for e in errMsg:
                for l in lines:
                    if re.search(e,l):
                        print(makelatexUtil.getWarnColorCode() + basename+": " + makelatexUtil.getResetColorCode() + l.rstrip())

        with open(self.MLTMP+"latex-"+basename+".log") as f:
            lines = f.readlines()

        # numbers are the number of lines before and after the
        # matching line to print.
        errMsg = [ [ 0, 0, "Overfull"],
                   [ 0, 0, "Underfull"],
                   [ 0, 0, "Warning:"],
                   [ 0, 0, "Error:"],
                   [ 0, 0, "LaTeX Error"],
                   [ 0, 0, "! I can't"],
                   [ 0, 0, "!pdfTeX error"],
                   [ 0, 0, "---!"],
                   [ 0, 0, "Fatal"],
                   [ 0, 0, "not defined"],
                   [ 0, 0, "undefined"],
                   [ 0, 0, "improper"],
                   [ 0, 0, "required"],
                   [ 0, 0, "requires"],
                   [ 0, 0, "You must"],
                   [ 0, 0, "Fatal format file error"],
                   [ 0, 0, "This exam"], # exam.cls
                   [ 0, 0, "No file"],
                   [ 1, 1, "LaTeX Warning"],
                   [ 1, 1, "pdfTeX Warning"],
                   [ 0, 2, "Package fontspec Warning:"],
                   [ 0, 1, "Undefined control sequence"],
                   [ 0, 1, "Runaway argument"],
                   [ 0, 4, "./" + basename + ".tex:" ],
                   [ 0, 2, "./" + basename + ".bbl:" ] ]

        linesToPrint = []
        for e in errMsg:
            for l in range(len(lines)):
                if re.search(e[2],lines[l], flags=re.IGNORECASE):
                    # Don't warn about missing basename.aux
                    #
                    # Hide common xelatex error (TODO: Remove this check when
                    # problem is fixed:
                    # http://tex.stackexchange.com/questions/46683/
                    if lines[l].strip() != "No file " + basename + ".aux." and not re.search("xparse/redefine-command", lines[l]):
                        linesToPrint.extend( range(l-e[0], l+e[1]+1) )

        # we may have selected to print the same line twice, and our ranges may
        # be out of bounds. Also, we may have selected some blank lines to
        # print.  Remove duplicates and print non-empty lines:
        linesToPrint = makelatexUtil.dedup(linesToPrint)
        linesToPrint.sort()
        for l in linesToPrint:
            if l>=0 and l<len(lines) and len(lines[l].strip()) > 0:
                print(makelatexUtil.getWarnColorCode() + basename+": " + makelatexUtil.getResetColorCode() + lines[l].rstrip())


    def printDvipsError(self, basename):
        """Analyzes the dvips logs for the given file (given by its basename) and prints any errors/warnings to the console."""
        if os.path.exists(self.MLTMP+basename+".log"):
            with open(self.MLTMP+basename+".log") as f:
                lines = f.readlines()

        errMsg = [ [ 1, 1, "\(Mismatched mode\)"],
                   [ 0, 0, "\(may be too complex to print\)"] ]

        linesToPrint = []
        for e in errMsg:
            for l in range(len(lines)):
                if re.search(e[2],lines[l]):
                    linesToPrint.extend( range(l-e[0], l+e[1]+1) )

        # we may have selected to print the same line twice, and our ranges may
        # be out of bounds. Also, we may have selected some blank lines to
        # print.  Remove duplicates and print non-empty lines:
        linesToPrint = makelatexUtil.dedup(linesToPrint)
        linesToPrint.sort()
        for l in linesToPrint:
            if l>=0 and l<len(lines) and len(lines[l].strip()) > 0:
                makelatexUtil.printWarn(basename + ": " + lines[l].strip())




    def needsRerun(self, basename, printMessages=False):
        """Analyzes the logs for the given file (given by its basename) and returns true if we need to recompile the latex document."""
        string = open(self.MLTMP+"latex-"+basename+".log").read()
        msg = [ 'LaTeX Warning: Label\(s\) may have changed',
                "Citation.*undefined.*",
                "No file " + basename + ".toc", # table of contents
                "No file " + basename + ".nav", # beamer presentation
                "Rerun to get",
                "LaTeX Warning: There were undefined references",
                "Package natbib Warning: There were undefined citations.",
                "Package natbib Warning: Citation\(s\) may have changed." ]

        # if printMessages, print all messages:
        if printMessages:
            for m in msg:
                if re.search(m, string):
                    makelatexUtil.printWarn(self.outfmt % (basename, re.search(m,string).group(0)))

        # search again, if we find a message, return True.
        for m in msg:
            if re.search(m, string):
                return True
        return False




    # Finds matches, removes duplicates, returns matching strings
    # Example: findMatches(["foo(.*)bar", "bar(.*)foo" ], filename)
    def findMatches(self, regexs, filename):
        matches = []
        try:
            for r in regexs:
                f = open(filename)
                for line in f:
                    matches.extend(re.findall(r, line))
                f.close()
        except IOError:
            makelatexUtil.printError("Error opening or reading file: " + filename)
            makelatexUtil.printWarn("NOTE: makelatex may not work properly if you do not change into the directory which contains the document before you run it.")
            exit(1)
        return makelatexUtil.dedup(matches)


    def getImagesInTexFiles(self, texfiles):
        """Returns a list of images in the texfiles.  The strings returned are exactly how they appear in the texfile.  (i.e., they may be missing extensions)"""
        ret = []
        for i in texfiles:
            if not i.endswith(".pdf"):
                ret.extend(self.findMatches([ "^[^%]*\\\\includegraphics\[[^]]*\]{([^}]*)}",
                                              "^[^%]*\\\\includegraphics{([^}]*)}" ], i))
        return makelatexUtil.dedup(ret)

    def getImagesInTexFile(self, texfile):
        """Returns a list of images in a single texfile"""
        return self.getImagesInTexFiles([texfile])



    def getIncludedInTex(self, texfile, depth=3):
        """Returns a list of .sty files, .bib files, included .tex files, and included .pdf files in the latex document.  The files returned by this function are either absolute paths or relative paths beginning with './'"""

        incList = []

        if texfile.startswith("/"):
            incList.append(texfile)
        else:
            incList.append(makelatexUtil.findFileInPaths(texfile, makelatexUtil.getEnviron('TEXINPUTS')))

        if depth <= 0:
            return incList

        # Include the graphicspath in our TEXINPUTS path so uconvert can find images
        # Format: \graphicspath{{path1/}{path2/}{path3/}}
        # The trailing / after each path is required
        #
        # TODO: This means that the path applies to all .tex files we are
        # building---which may not be intended.
        gpath = self.findMatches(["^[^%]*\\\\graphicspath{{(.*)}}"], texfile)
        for i in gpath:
            entries = i.split('}{');
            currentInputs = makelatexUtil.getEnviron("TEXINPUTS").split(os.pathsep)
            for e in entries:
                if currentInputs.count(e) == 0:
                    os.environ["TEXINPUTS"] =       e + os.pathsep + makelatexUtil.getEnviron("TEXINPUTS")
                    os.environ["TEXINPUTS_NOTMP"] = e + os.pathsep + makelatexUtil.getEnviron("TEXINPUTS_NOTMP")

        # Find bibliography files that we are using
        matches = []
        matches.extend(self.findMatches(["^[^%]*\\\\bibliography{(.*)}"], texfile))
        # \nobibliography is used by bibentries package
        matches.extend(self.findMatches(["^[^%]*\\\\nobibliography{(.*)}"], texfile))

        # multibib support: find other bibtex files that are used
        mbibNames = self.findMatches(["^[^%]*\\\\newcites{(.*)}{.*}"], texfile)
        for i in mbibNames:
            matches.extend(self.findMatches(["^[^%]*\\\\bibliography"+i+"{(.*)}"], texfile))
        # Split up the comma-separated entries into separate items
        matches = makelatexUtil.dedup(matches)
        for match in matches:
            for s in match.split(","):
                name = makelatexUtil.findFileInPaths(s+".bib", makelatexUtil.getEnviron('BIBINPUTS'))
                if name and incList.count(name) == 0:
                    incList.append(name)

        # Find sty files that we depend on
        texinputs = makelatexUtil.getEnviron('TEXINPUTS_NOTMP')
        matches = self.findMatches(["^[^%]*\\\\usepackage\[.*\]{([^}]*)}",
                               "^[^%]*\\\\usepackage{([^}]*)}" ], texfile)
        for match in matches:
            for s in match.split(","):  # multiple packages can be comma delimited
                name = makelatexUtil.findFileInPaths(s+".sty", texinputs)
                if not name:
    #                if not makelatexUtil.findFileInPaths(s+".sty", texinputs, kpathsea=True):
    #                    makelatexUtil.printWarn("Potential dependency is missing: "+s+".sty" + " needed by "+texfile)
                    continue
                if incList.count(name) == 0:
                    incList.extend(self.getIncludedInTex(name, depth=depth-1))

        matches = self.findMatches(["^[^%]*\\\\RequirePackage\[.*\]{([^}]*)}",
                                    "^[^%]*\\\\RequirePackage{([^}]*)}"], texfile)
        for match in matches:
            for s in match.split(","):  # multiple packages can be comma delimited
                name = makelatexUtil.findFileInPaths(s+".sty", texinputs)
                if not name:
    #                if not makelatexUtil.findFileInPaths(s+".sty", texinputs, kpathsea=True):
    #                    makelatexUtil.printWarn("Potential dependency is missing: "+s+".sty" + " needed by "+texfile)
                    continue
                if incList.count(name) == 0:
                    # recursively handle dependencies (and find the images in the file)
                    incList.extend(self.getIncludedInTex(name, depth=depth-1))

        # NOTE: \input will basically copy/paste the contents of the other file
        # into the current file.  \include will render the included information
        # seperately (i.e., force a page break after the included content).
        matches = self.findMatches(["^[^%]*\\\\input{([^}]*)}",
                               "^[^%]*\\\\include{([^}]*)}"], texfile)
        for match in matches:
            exten = [ "", ".tex" ]   # TODO: Remove extensions first?
            for e in exten:
                name = makelatexUtil.findFileInPaths(match + e, texinputs)
                if not name:
    #                if not makelatexUtil.findFileInPaths(match+e, texinputs, kpathsea=True):
    #                    makelatexUtil.printWarn("Potential dependency is missing: "+match+e + " needed by "+texfile)
                    continue
                if incList.count(name) == 0:
                    incList.append(name)
                    # recursively handle dependencies:
                    incList.extend(self.findPotentialDependencies(name, depth=depth-1))

        matches = self.findMatches([ "^[^%]*\\\\includepdf\[.*\]{(.*)}",
                                     "^[^%]*\\\\includepdf{(.*)}" ], texfile)
        for s in matches:
            # file extension is optional in \includepdf so we'll deal
            # with both cases.
            if not s.endswith(".pdf"):
                s = s+".pdf"
            # find the PDF
            name = makelatexUtil.findFileInPaths(s, texinputs)
            # if PDF file isn't found, look for a tex file that we could
            # potentially use to create it
            if not name:
                name = makelatexUtil.findFileInPaths(makelatexUtil.stripExten(s,".pdf")+".tex", texinputs)
            # Add a dependency on the PDF if we found a matching PDF or tex file.
            if name:
                incList.append(name)

        return incList



    # Returns a list of files used by a tex file. This list is primarily used
    # only to determine if some of the files that we depend on have changed
    # since we created the last PDF.
    #
    # * It doesn't hurt (much) if we include files that aren't actually
    #   dependencies.
    #
    # * Paths to files will be absolute or begin with ./
    #
    # * Some of the files returned by this function may not exist (example: If
    # * the user did an \includepdf{b} and b.pdf doesn't exist, but b.tex does
    # * (i.e., user is expecting us to make b.pdf for them).
    #
    # * All of the image files that we return will exist. If we can't find the
    # * source image, we don't know what extension the user intended to use
    # * because anything they have inside of includegraphics could have any
    # * number of extensions added to it!
    #

    def findPotentialDependencies(self, texfile, depth=3):
        depend = []
    # This isn't ideal because we don't know the file extension that we are
    # looking for. The convertImages() function will actually do the conversion
    # of these files to a latex-appropriate format. We should look for highest
    # quality files first!
        exten = [ "", ".svg", ".svgz", ".eps", ".ps",
                  ".pdf", ".mp", ".mps", ".png", ".gif",
                  ".tif", ".tiff", ".bmp", ".jpg", ".jpeg" ]
        images = self.getImagesInTexFile(texfile)
        for i in images:
            for e in exten:
                f = makelatexUtil.findFileInPaths(i + e, makelatexUtil.getEnviron('TEXINPUTS_NOTMP'))
                if f:
                    depend.append(f)

        depend.extend(self.getIncludedInTex(texfile, depth))

        if os.path.exists("./prepost.sh"):
            depend.append("./prepost.sh")

        return makelatexUtil.dedup(depend)


    # Put lossy file formats (like JPG) at the end of the list.
    def supportedImageExten(self, engine):
    # NOTE: If a .mp (metapost) image file is present, we will request a .ps or
    # .mps file from uconvert (depending on engine). Otherwise, we assume that
    # everybody should be using one of the formats below when including
    # imagery.
        if engine == "latex":
            return ".eps".split(" ")
        if engine == "pdflatex":
            return ".pdf .png .jpg".split(" ")
        if engine == "lualatex":
            return ".pdf .png .jpg".split(" ")
        if engine == "xelatex":
            return ".eps .pdf .png .jpg".split(" ")

    def convertImages(self, texfiles):
        if self.args.noconvert:
            return

        # If force requested, remove any images that already exist
        if self.args.force and os.path.exists(self.tmpUconvertDir):
            shutil.rmtree(self.tmpUconvertDir)

        # Generate the list of images (with extensions) that we need.  Since
        # latex allows you to include images without specifying extensions and
        # because different engines support different file formats, this gets
        # a little complex:
        imageWithExten = []

        # The tex files may include other tex files that include images
        texfilesWithDep = []
        for t in texfiles:
            texfilesWithDep.extend(self.getIncludedInTex(t))

        for image in self.getImagesInTexFiles(texfilesWithDep):
            # image is the image name as it appears in the tex file!
            imageLow = image.lower()

            # If the user specified an extension supported by the engine, then
            # we know the file we need to create. We will add the file to
            # imageWithExten list and move on to the next image.
            okExten = False
            for i in self.supportedImageExten(self.args.engine):
                if not okExten and imageLow.endswith(i):
                    imageWithExten.append(image)
                    okExten = True

            if okExten:
                continue

            # If we get to here, the string doesn't have an extension, or it
            # has one and it doesn't work with the engine.

            # It looks like there is an 2 or 3 character extension, print
            # warning and do what user requested.
            if len(image) > 4 and (image[-3]=='.' or image[-4]=='.'):
                makelatexUtil.printWarn("WARNING: \"" + image + "\" might not be supported by the \"" + self.args.engine + "\" engine .")
                makelatexUtil.printWarn("Suggestion: Don't specify an extension and let this script handle conversions.")
                # If they specified it, trust the user and forget uconvert:
                imageWithExten.append(image)
                continue

            # Now, we are confident that there is no extension

            # Look for an existing image file that is in the format that is
            # supported by our engine.
            choices = []
            paths = makelatexUtil.getEnviron('TEXINPUTS_NOTMP')
            for i in self.supportedImageExten(self.args.engine):
                choices.append(makelatexUtil.findFileInPaths(image+i, paths))
            while None in choices:
                choices.remove(None)

            # If we can't find an appropriate file that already exists, we'll
            # ask uconvert to make us a pdf (or eps) from all of the file
            # formats it supports. Of course, it might fail!
            if len(choices)==0:
                # Differt engines prefer .mp files to be converted differently.
                if makelatexUtil.findFileInPaths(image+".mp", paths):
                    if self.args.engine == "latex" or self.args.engine == "xelatex":
                        imageWithExten.append(image+".ps")
                    else:
                        imageWithExten.append(image+".mps")

                # Otherwise, if using latex engine, ask uconvert for a EPS:
                elif self.args.engine == "latex":
                    imageWithExten.append(image+".eps")
                else:
                    # If using any other engine, ask uconvert for a PDF
                    # (TODO: Is this arbitrary choice is best?)
                    imageWithExten.append(image + ".pdf")
            else:
                # If we found an existing image in a supported format, use it.
                exten = "." + choices[0].rsplit(".", 1)[1]
                imageWithExten.append(image + exten)

        # Now, imageWithExten contains all of the images that we are going to
        # use with the document.

        # Create directory for converted images, OK if it already exists:
        try: os.mkdir(self.tmpUconvertDir)
        except OSError: pass

        if len(imageWithExten) == 0:
            return

        # Do the conversion:
        uc = uconvert(verbose=0,
                      srcdir=makelatexUtil.getEnviron("TEXINPUTS"),
                      destdir=self.tmpUconvertDir)
        for arg in makelatexUtil.dedup(imageWithExten):
            if not uc.processFile(arg):
                makelatexUtil.printWarn("WARNING: Failed to convert file: " + arg)


    # paramName = actual parameter provided to makelatex
    # paramValue = true/false or the string given with the param to makelatex
    # command = The command that we need to run
    # otherCommandArgs = Extra parameters we need to give pdfnup.
    # path = full path to file to create nup from
    # extension = basename.extension.pdf will be used to store the output file
    def createNupCommand(self, paramName, paramValue, command, otherCommandArgs, path, extension):
        if not paramValue:
            return
        if not makelatexUtil.findFileInPaths(command):
            makelatexUtil.printError(command + " command is needed for " + paramName)
            return
        outfile = makelatexUtil.bname(path)+"."+extension+".pdf"
        commandargs = ["--outfile", outfile]
        commandargs.extend(self.PDFNUP_ARGS.split())
        commandargs.extend(otherCommandArgs)
        # use same paper size as input PDF if it is letter or A4
        pageSize = self.getPdfStats(path)['pageSize']
        if pageSize == "letter paper":
            commandargs.extend(["--paper", "letterpaper"])
        elif pageSize == "A4 paper":
            commandargs.extend(["--paper", "a4paper"])
        else: # otherwise, use the hardcoded variable indicating paper size
            commandargs.extend(["--paper", self.PDFNUP_PAPER])
        commandargs.append(path)  # input file
        if not self.args.quiet: print(self.outfmt % (makelatexUtil.bname(path), "pdfnup"))
        self.runCommand(command, commandargs, shell=False)

        self.embedFonts(outfile)
        self.linearizePdf(outfile)


    def createNupHandout(self, path):
        self.createNupCommand("--nupHandout", self.args.nupHandout, "pdfjam-slides3up",
                              [], path, "handout")

    def createNupLand(self, path):
        self.createNupCommand("--nupLand", self.args.nupLand, "pdfnup",
                              [ "--scale", ".85", "--landscape", "--nup", self.args.nupLand ],
                              path, self.args.nupLand)

    def createNupPort(self, path):
        self.createNupCommand("--nupPort", self.args.nupPort, "pdfnup",
                              [ "--scale", ".85", "--no-landscape", "--nup", self.args.nupPort ],
                              path, self.args.nupPort)


    def createNup(self, path):
        """Create the requested nup PDFs given a path to the source PDF."""
        if not os.path.exists(path):
            return
        self.createNupHandout(path)
        self.createNupPort(path)
        self.createNupLand(path)



    def processTexFile(self, path):
        """Generates a PDF from the given tex file. Returns true if PDF was successfully created."""
        if not os.path.exists(path):
            makelatexUtil.printError("ERROR: LaTeX source file does not exist: " + path)
            return

        basename = makelatexUtil.bname(path)
        # runOK will be true even if there were undefined references, etc
        runOK = self.runLatex(basename)

        if not runOK:
            self.printLatexWarn(basename)
            makelatexUtil.printError("ERROR: Latex indicated an error (but PDF may have been created).")
            makelatexUtil.printWarn("Suggestion: If you don't see errors above, look at the log files in the \"" + self.MLTMP + "\" subdirectory.")
            self.args.keep = True

            # Sleep for 5 seconds if we are looping so that we don't just
            # repeatedly recompile the file over and over again.
            #
            # TODO: We could do something better. For example, we could get the
            # mtime of all the source files here, and then wait until the mtime
            # on one of the files changed before attempting to recompile.
            if self.args.loop:
                time.sleep(5)
            return False

        # If we have to run bibtex or makeindex, we have to rerun latex at
        # least one time
        mustRunAgain = self.runBibtex(basename)
        mustRunAgain = mustRunAgain + self.runMakeindex(basename)
        mustRunAgain = mustRunAgain + self.runMakeglossaries(basename)
        if mustRunAgain:
            self.runLatex(basename)

        # Run latex in a loop up to 5 times if needed
        count = 5
        while count > 0:
            if(self.needsRerun(basename)):
                count = count-1
                runOK = self.runLatex(basename)
            else:
                count = -100

        # Look for warnings and print them out
        self.printLatexWarn(basename)

        if count == 0:
            # There must have been undefined references. Run again and
            # print them this time.
            self.needsRerun(basename, printMessages=True)
            return False

        # If last run failed or if PDF is missing, we failed.
        if not runOK or not os.path.exists(basename + ".pdf"):
            makelatexUtil.printError(self.outfmt % (basename, "ERROR: Failed to create PDF or return code indicated an error."))
        else:
            self.runDvips(basename)   # Convert dvi to pdf if necessary
            # The commands change the modified time of the PDF, set it back to
            # the time we started to build the PDF:
            self.updatePdfMtime(basename)

        return runOK



    def updatePdfMtime(self, path):
        if not os.path.exists(path) or not makelatexUtil.findFileInPaths("touch"):
            return

        # makes the PDF mtime and atime match the time we started this script
        os.utime(path, (self.makelatex_start_time, self.makelatex_start_time))

        # Evince doesn't seem to automatically reload the file unless we
        # update the access time with the "touch" command.
        self.runCommand("touch", [ "-a", path ], shell=False)
    # The above touch command should be the same as running the
    # following, but "touch" works and the following doesn't for some
    # reason...
    # os.utime(path, (time.time(), makelatex_start_time))


    def callFunctionWithThreads(self, funcName, funcArgs):
        """Calls a function multiple times---once with each argument. If
        threads are requested, we call each function in its own thread."""
        if len(funcArgs) == 0:
            return

        for i in funcArgs:
            if not self.args.threads:
                funcName(i)
            else:
                threading.Thread(target=funcName,args=(i,)).start()

        # wait for all threads to finish if we're using threading
        if self.args.threads:
            while threading.activeCount() > 1:
                time.sleep(.2)


    def findNonAsciiChars(self, files):
        """Given a list of files, print out lines which contain non-ASCII
        characters"""
        if self.args.nonascii == False or self.args.quiet:
            return

        # Find sty and bib files that the tex files use:
        asciiToCheck = []
        for f in files:
            asciiToCheck.append(f)
            deps = self.findPotentialDependencies(f)
            for d in deps:
                if d.endswith(".sty") or d.endswith(".bib"):
                    asciiToCheck.append(d)

        havePrintedMessage = False
        for f in asciiToCheck:
            try:
                lineNo = 0
                for line in open(f):
                    lineNo = lineNo+1
                    if not all(ord(c) < 128 for c in line):
                        if not havePrintedMessage:
                            havePrintedMessage = True
                            makelatexUtil.printWarn("Non-ASCII characters in file:")
                        sys.stdout.write(makelatexUtil.getWarnColorCode() + f + ":" + str(lineNo) + makelatexUtil.getResetColorCode() + ": ")
                        for c in line:
                            if ord(c) < 128:
                                sys.stdout.write(c)
                            else:
                                sys.stdout.write(makelatexUtil.getWarnColorCode() + c + makelatexUtil.getResetColorCode())


            except IOError:
                pass

    def processTexFiles(self):
        """Determines which tex files that we should create PDFs for and
        creates them."""

        self.runPrePost("pre")

        files = self.getTexFiles()
        self.findNonAsciiChars(files)
        self.makeSuggestions(files)

        # Update the time we started in a global variable---used to set mtime
        # of PDFs we create.
        self.makelatex_start_time = time.time()

        triedToBuild = [] # list of tex files we tried to build

        # We need this outside loop to correctly rebuild files that have
        # \includepdf. For example if a.tex has \includepdf{b.pdf} and b
        # changes, we will only rebuild B.pdf the first time through the loop.
        # The second time through the loop, B.pdf will have changed and we will
        # detect that A needs to be rebuilt too.
        origForceFlag = self.args.force
        for j in range(0,10):
            # Print message if no texfiles
            texfilelist = self.getTexFiles()
            if len(texfilelist) == 0:
                makelatexUtil.printError("ERROR: No files given as arguments, no tex files found.")
                return

            # Prune the texfile list to just the files that need updating AND
            # the files that we haven't already tried to build in a previous
            # time through the loop. This is needed because if we failed to
            # build a file, we would repeatedly try to build it inside of the
            # above loop.  If force flag is set, isUpdateNeeded() will always
            # return true.
            needUpdate = []
            for texfile in texfilelist:
                if triedToBuild.count(texfile) == 0 and self.isUpdateNeeded(texfile):
                    needUpdate.append(texfile)
            texfilelist = needUpdate

            # break out of loop when nothing to update
            if len(texfilelist) == 0:
                break

            # If the same image is in multiple tex files, we only want to
            # convert the image once. Therefore, convert the images here
            # instead of doing it in the loop below which uses seperate threads
            # per document. (NOTE: uconvert uses one thread per image if
            # multiple images are being converted).
            self.convertImages(texfilelist)

            # Create pdfs from each tex file
            for i in texfilelist:
                triedToBuild.append(i)

            self.callFunctionWithThreads(self.processTexFile, texfilelist)

            # Ignore the --force flag after first time through loop.
            if self.args.force:
                self.args.force=False
        # Restore force flag to whatever it was before
        # the loop.
        self.args.force = origForceFlag

        # Optimize PDF and create nup versions regardless of if files need
        # updating.
        texfilelist = self.getTexFiles()
        if len(texfilelist) > 0:
            pdffilelist = []
            for f in texfilelist:
                pdffilelist.append(makelatexUtil.changeExten(f, ".tex", ".pdf"))
            self.callFunctionWithThreads(self.embedFonts, pdffilelist)
            self.callFunctionWithThreads(self.linearizePdf, pdffilelist)
    #        self.callFunctionWithThreads(self.greyscalePdf, pdffilelist)
            self.callFunctionWithThreads(self.screenPdf, pdffilelist)
            self.callFunctionWithThreads(self.createNup, pdffilelist)

        # Print all of the stats together at the end so they don't get buried
        # in all of the output.  Don't show messages if we are looping due to
        # "-l" option and we didn't need to build anything this time through
        # the loop.
        for i in texfilelist:
            if not self.args.loop or (self.args.loop and len(triedToBuild) > 0):
                self.printPdfStatsPath(makelatexUtil.changeExten(i, ".tex", ".pdf"))

        self.runPrePost("post")

    # Remove lockfile. Automatically called when exit() is called.
    def cleanupLock(self):
        makelatexUtil.removeIfExist(self.lockfile)
        # Remove makelatex-tmp now unless user requested that we keep it
        if not self.args.keep:
            self.cleanupEverything()
        if self.args.loop and self.requestedOptimize:
            makelatexUtil.printWarn("Rerun without --loop or -l to optimize PDF.")
            makelatexUtil.printWarn("  (Makelatex disables optimization when looping is used.)")

    def runPrePost(self, param=""):
        """Runs the prepost.sh with the given parameter if it exists. If the file exists but is not executable, print an error message."""
        prepostFile = './prepost.sh'
        if os.path.exists(prepostFile):
            try:
                subprocess.call([prepostFile, param])
            except OSError:
                makelatexUtil.printError("Can't execute file: " + prepostFile + " " + param)


if __name__ == '__main__':
    ml = makelatex()

    atexit.register(ml.cleanupLock) # cleanup lockfile on exit()
    l = open(ml.lockfile, "w") # create lockfile
    l.close()

    try: # catch ctrl+c interrupt below
        if ml.args.clean:
            # prepost.sh can make a tex file, so we need to
            # make it to detect all the pdfs that we could
            # remove:
            ml.runPrePost("pre")
            ml.cleanupEverything(ml.getTexFiles())
            makelatexUtil.removeIfExist("makelatex-diff.pdf") # getTexFiles() may not contain makelatex-diff.tex---since we delete it.
            ml.runPrePost("post")
            exit(0)

        if ml.args.loop:
            # Loop forever, or until someone deletes our lockfile
            while os.path.exists(ml.lockfile):
                ml.processTexFiles()
                time.sleep(1)
            print("makelatex: Lockfile disappeared, exiting...");

        else:
            ml.processTexFiles()

    except KeyboardInterrupt:
        ml.runPrePost("interrupt")
        print("")
        print("makelatex: Cleaning up...")
        exit(1)
