#!/usr/bin/env python
#
# makelatex - version: 0.94
# http://www.cs.mtu.edu/~kuhl/software/makelatex
#
#
# Copyright (C) 2011--2012 Scott A. Kuhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import subprocess, os, sys, shutil, argparse, re, time, atexit
import threading, traceback

MLTMP = "makelatex-tmp/"

# used by both latex and pdflatex
LATEX_ARGS = "-file-line-error -interaction=nonstopmode -output-directory="+MLTMP
DVIPS_ARGS = "-Ppdf -G0"
PDFNUP_ARGS = "--frame true --keepinfo --quiet"
# We automatically select a papersize for pdfnup that matches the input
# PDF. If the input is neither "a4paper" or "letterpaper", we will use the
# following:
PDFNUP_PAPER = "letterpaper"

# PS2PDF argument listing:
# http://pages.cs.wisc.edu/~ghost/doc/cvs/Ps2pdf.htm
# http://ghostscript.com/doc/current/Ps2pdf.htm
# -dPDFA = creates PDF/A documents
# Try to embed all fonts. Use lossless image compression. Don't downsample images.
#PS2PDF_ARGS = "-dPDFSETTINGS=/prepress -dAutoRotatePages=/None -dEmbedAllFonts=true -dMaxSubsetPct=100 -dSubsetFonts=true -dAutoFilterColorImages=false -dAutoFilterGrayImages=false -dColorImageFilter=/FlateEncode -dGrayImageFilter=/FlateEncode -dMonoImageFilter=/FlateEncode -dDownsampleColorImages=false -dDownsampleGrayImages=false -dDownsampleMonoImages=false"

# Same as above, but we don't insist on lossless images. For example,
# lualatex will encode lossy images JPEG images---and then running the
# resulting PDF through ps2pdf would then produce a much larger PDF:
PS2PDF_ARGS = " -dPDFSETTINGS=/prepress " \
    "-dAutoRotatePages=/None " \
    "-dEmbedAllFonts=true " \
    "-dMaxSubsetPct=100 " \
    "-dSubsetFonts=true " \
    "-dAutoFilterColorImages=false " \
    "-dAutoFilterGrayImages=false " \
    "-dDownsampleColorImages=false " \
    "-dDownsampleGrayImages=false " \
    "-dDownsampleMonoImages=false "

PS2PDF_ARGS_SCREEN = " -dPDFSETTINGS=/screen " \
    "-dAutoRotatePages=/None " \
    "-dEmbedAllFonts=true " \
    "-dMaxSubsetPct=100 " \
    "-dSubsetFonts=true " \
    "-dColorImageResolution=150 " \
    "-dGrayImageResolution=150 " \
    "-dMonoImageResolution=300 "

PS2PDF_ARGS_GREY = PS2PDF_ARGS + " " \
    "-sColorConversionStrategy=Gray " \
    "-dProcessColorModel=/DeviceGray "


lockfile = ".makelatex.lock"
outfmt = '%20s: %s'
tmpUconvertDir = MLTMP + "uconvert"

# requestedOptimize helps determine if we need to print a message about
# optimization when we exit from --loop or -l mode:
requestedOptimize = False

makelatex_start_time = time.time()



class bcolors:
    FAIL = '\033[91m\033[1m'  # red, bold
    WARN = '\033[93m\033[1m'  # yellow, bold
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def printError(msg):
    """Prints a highlighted error message to stdout."""
    print(bcolors.FAIL + msg + bcolors.ENDC)
def printWarn(msg):
    """Prints a highlighted warning message to stdout."""
    print(bcolors.WARN + msg + bcolors.ENDC)

# Gets an environment variable or returns an empty string if variable is
# not set.
def getEnviron(name):
    """Gets an environment variable. Returns an empty string if variable is
    not set"""
    if name in os.environ:
        return os.environ[name]
    else:
        return ""

## --------------------------------------
## Parse arguments:
## --------------------------------------

parser = argparse.ArgumentParser(description='Build PDF files from LaTeX files.')

parser.add_argument('texfiles', metavar='X.tex', type=str, nargs='*',
                    help='One or more tex files, if none provided, we will guess.')
parser.add_argument('-f', '--force', action="store_true",
                    help='Recreate pdf even if one already exists')
parser.add_argument('-o', '--optimize',  action="store_true",
                    help='Try to PDFs smaller with ps2pdf and linearize PDF with pdfopt')

# TODO: Threading is disabled by default since there we sometimes have one
# thread hang on a subprocess.call() which causes us to hang. Once
# threading works reliably, we should change this to --nothreads.
parser.add_argument('-t', '--threads',  action="store_true",
                    help='Compile each document in its own thread.')

parser.add_argument('--noconvert',  action="store_true",
                    help='Don\'t automatically convert images')
parser.add_argument('-l', '--loop', action="store_true",
                    help='Make repeatedly')
parser.add_argument('-k', '--keep', action="store_true",
                    help='Keep makelatex-tmp folder containing logs and converted images')
parser.add_argument('-c', '--clean', action="store_true",
                    help='Just cleanup, don\'t build tex files')
parser.add_argument('-e', '--engine',
                    help="latex (uses dvips and ps2pdf), pdflatex, xelatex, or lualatex. You can also set this with the MAKELATEX_ENGINE environment variable.")
# Default to synctex ON
#parser.add_argument('-s', '--synctex', action="store_false",
#                    help="Use synctex (your editor must support it)")
# Default to synctex OFF
parser.add_argument('-s', '--synctex', action="store_true",
                    help="Use synctex (your editor must support it)")
# Overview of synctex: http://www.tug.org/TUGboat/tb29-3/tb93laurens.pdf
# Can be enabled in documents with \synctex=1
# evince 2.32 supports synctex through Ctrl+LeftClick
# gedit supports it through a plugin
# Emacs supports it with some help: http://www.emacswiki.org/emacs/AUCTeX
# pdflatex and xelatex supports it since TexLive 2008

parser.add_argument('--nupLand', metavar="NxN",
                    help="2x1 (2 pages per 1 landscape page, side by side); 1x2 (above/below); etc")
parser.add_argument('--nupPort', metavar="NxN",
                    help="2x1 (2 pages per 1 portrait page, side by side); 1x2 (above/below); etc")
parser.add_argument('--nupHandout', action="store_true",
                    help="3 pages per page with room for notes (useful for presentations)")
parser.add_argument('--greyscale', '--grayscale', action="store_true",
                    help="Convert output pdf to greyscale.")
parser.add_argument('--screen', action="store_true",
                    help="Compress images in PDF more heavily (reduce image resolution, use lossy image compression)")
# TODO: We should automatically trigger --nonascii if it looks as if the
# user really did want to use UTF8 (or some other encoding) in their files.
parser.add_argument('--nonascii', action="store_true",
                    help="Don't warn about non-ASCII characters in tex files.")
parser.add_argument('--nowarn', '--nowarnings', '--nw', action="store_true",
                    help="Don't check for problems using lacheck, chktex or bibtex prior to compiling document.")
parser.add_argument('--quiet', '-q', action="store_true",
                    help="Turns on --nowarn and --nonascii. Also hides other output except for warnings/errors and PDF statistics.")
parser.add_argument('--diff', nargs=2, metavar=('old.tex', 'new.tex'),
                    help="Generates a PDF showing differences between two versions of a document (requires latexdiff command).")




args = parser.parse_args()


## --------------------------------------
## Functions:
## --------------------------------------

def fileOnly(path):
    """Converts a path string into a filename (removes everything before
    the last '/')"""
    return os.path.split(path)[1]

def pathOnly(path):
    """Converts a path to a file to the path only (removes everything after
    the last '/'). Result contains trailing '/'"""
    t = os.path.split(path)[0]
    if not t.endswith(os.sep):
        t = t + os.sep
    return t


# Given a full path or a file, return the basename
def bname(path):
    """Returns the basename (file name without extension) given a full path
    or a filename."""
    return stripExten(fileOnly(path))

def stripExten(filename, exten=None):
    """Strips everything after that last . from the end of the filename. If
    exten is set to a string, we will only remove the extension if it
    matches that string"""
    if exten:
        if filename.endswith(exten):
            return filename[:-len(exten)]
        return filename
    else:
        return filename.rsplit('.', 1)[0]

def stripTexEnding(string):
    """Remove .tex from the end of the string (if it exists)"""
    return stripExten(string, ".tex")
def stripPdfEnding(string):
    """Remove .pdf from the end of the string (if it exists)"""
    return stripExten(string, ".pdf")

def texToPdf(path):
    """Strips a .tex ending and adds a .pdf ending"""
    return stripTexEnding(path)+".pdf"


def makeSuggestions(texfiles):
    """Runs chktex, lacheck, and bibcheck (if they are installed) to make
    suggestions to the user"""
    if args.nowarn or args.quiet:
        return

    # Change list of texfiles to basenames:
    bnames = map(fileOnly, texfiles)

    # chktex
    for i in bnames:
        logfile = MLTMP+"chktex-"+i+".log"
        removeIfExist(logfile)
        runCommand("chktex", [ "-q", "-v3", "--nowarn", "1", "-o", logfile, i ], shell=False, silentFail=True)
        if os.path.exists(logfile) and len(open(logfile).read()):
            printWarn("chktex warnings for " + i + " :")
            for line in open(logfile):
                print(bcolors.BOLD + line.rstrip().replace("\""+i+"\", ", "") + bcolors.ENDC)

    # lacheck
    for i in bnames:
        logfile = MLTMP+"lacheck-"+i+".log"
        runCommand("lacheck", i + " > " + logfile, shell=True, silentFail=True)
        if os.path.exists(logfile) and len(open(logfile).read()):
            printWarn("lacheck warnings for " + i + " :")
            for line in open(logfile):
                # Lines starting with ** indicate that lacheck read an \include file
                if len(line.strip()) == 0 or line.startswith("** "):
                    continue
                print(bcolors.BOLD + line.rstrip().replace("\""+i+"\", ", "") + bcolors.ENDC)

    # bibcheck
    depend = []
    for i in bnames:
        depend.extend(findPotentialDependencies(i))
    depend = dedup(depend)
    for d in depend:
        if d.endswith(".bib"):
            logfile = MLTMP+"bibcheck-"+bname(d)+".log"
            runCommand("bibcheck", d + " > " + logfile, shell=True, silentFail=True)
            if os.path.exists(logfile) and len(open(logfile).read()):
                printWarn("bibcheck warnings for " + bname(d) + " :")
                for line in open(logfile):
                    if len(line.strip()) == 0:
                        continue
                    print(bcolors.BOLD + line.rstrip().replace(d+":", "line ") + bcolors.ENDC)




def getTexFiles():
    """Get list of tex files for us to process based on the arguments
    provided. If no arguments are provided, then we will find appropriate
    .tex file(s). All of the filenames returned will have a .tex
    ending---even if the user provided arguments that ended in .pdf"""

    # if there are no arguments, find matching tex files
    if not args.texfiles:
        texs = filesMatchingRegex('^[^%]*\\\\begin{document}')
    else:
        texs = []
        for i in args.texfiles:
            if i.endswith(".tex"): # we want .tex endings
                texs.append(i)
            # if we got .pdf ending and .tex file exists with same name, change argument:
            elif i.endswith(".pdf") and os.path.exists(i[:-4]+".tex"):
                texs.append(i[:-4]+".tex")
            # if nothing above worked, try adding .tex to the end
            elif os.path.exists(i + ".tex"):
                texs.append(i+".tex")
            else:
                printError("ERROR: Can't find .tex file corresponding to: "+i)
                exit(1)

    newtexs = []
    for t in texs:
        newtexs.append(findFileInPaths(t, getEnviron('TEXINPUTS')))

    texs = dedup(newtexs)


    # texs contains the files that we want to try to use.  We will put our final
    # list back into args.texfiles

    # There are dependencies if A.tex used \includepdf{B} and we are going
    # to create B.pdf.  In this case, we want to process B before A:

    # Loop is needed to sort out multiple levels of dependencies
    for numLoops in range(5):
        # Go through list of tex files in order. Find their dependencies
        # and make sure that we appear after them in the texfile list.
        newList = []
        for t in texs:
            deps = findPotentialDependencies(t)
            for d in deps:
                # If t depends on a PDF, and we are building a .tex file
                # with the same name.
                pdfToTex = stripExten(d)+".tex"
                if d.endswith(".pdf") and texs.count(stripExten(d)+".tex"):
                    # Don't use threading if there was a dependency
                    if args.threads == True:
                        args.threads = False
                        print("NOTE: Disabling threading since " + t + " depends on " + d)
                    # Add the tex file we depend on to the list (before adding t)
                    if newList.count(pdfToTex) == 0:
                        newList.append(pdfToTex)
            # Add this tex file to the list
            if not newList.count(t):
                newList.append(t)

        # if list is unchanged through loop, we
        # successfully figured out the dependencies
        if newList == texs:
            args.texfiles = texs
            return texs
        else:
            texs = newList


    # If we got here, we couldn't sort out the
    # dependencies...oh well...
    args.texfiles = texs
    return texs


# Given a directory, returns the list of files in the directory that match the
# provided regular expression.  Not recursive.
def filesMatchingRegex(regex, dir=os.getcwd()):
    ret = []

    for f in os.listdir(dir):

        # skip non-tex files
        if not f.endswith(".tex"):
            continue

        # Try opening file
        try:
            for line in open(f):
                if line and re.match(regex, line):
                    if ret.count(f) == 0:
                        ret.append(f)

        except IOError: # occurs if file isn't readable or for directories
            pass

    ret.sort()
    return ret



# Get ready to run, put tex files to compile in args.texfiles variable
def initialSetup():
    if args.diff:
        if findFileInPaths("latexdiff"):
            # allow users to specify basename, pdf, or tex file...change it to .tex file:
            args.diff[0] = stripTexEnding(stripPdfEnding(args.diff[0]))+".tex"
            args.diff[1] = stripTexEnding(stripPdfEnding(args.diff[1]))+".tex"
            if os.path.exists(args.diff[0]) and os.path.exists(args.diff[1]):
                runCommand("latexdiff", args.diff[0] + " " + args.diff[1] + " > makelatex-diff.tex", shell=True)
                args.texfiles.append("makelatex-diff.tex")
            else:
                printError("One of the tex files used with --diff does not exist: " + args.diff[0] + " " +args.diff[1])
                exit(1)
        else:
            printError("latexdiff is not installed.")
            exit(1)


    # Choose method to generate pdf if no choice is made by user
    if not args.engine and len(getEnviron("MAKELATEX_ENGINE")):
        args.engine = getEnviron('MAKELATEX_ENGINE')

    if not args.engine:
        if findFileInPaths("xelatex", getEnviron('PATH')):
            args.engine = "xelatex"
        elif findFileInPaths("pdflatex", getEnviron('PATH')):
            args.engine = "pdflatex"
        else:
            args.engine = "latex"
    # Note: We don't detect and use lualatex by default because there
    # hasn't been a stable release yet.

    # Allowed engines and their actual values:
    engines = { "xelatex"  : "xelatex",
                "xetex"    : "xelatex",
		        "x"        : "xelatex",
                "pdflatex" : "pdflatex",
                "latex"    : "latex",
                "dvips"    : "latex",
                "lua"      : "lualatex",
                "lualatex" : "lualatex",
                "luatex"   : "lualatex" }
    try:
        args.engine = engines[args.engine]
    except KeyError:
        printError("ERROR: Unknown engine selected: " + args.engine)
        exit(1)

    if args.synctex:
        global LATEX_ARGS
        LATEX_ARGS = LATEX_ARGS + " -synctex=1"
        # NOTE: I don't think plain "latex" supports synctex, but it doesn't
        # hurt to try to use it if the user requested it.

    # Optimizing the PDFs takes some time.
    # If user is running in loop mode, they probably
    # want immediate feedback---not small file sizes
    if args.loop and args.optimize:
        print("NOTE: Optimization is disabled in loop mode.")
        args.optimize=False
        # use the following to print message when we exit out of loop:
        global requestedOptimize
        requestedOptimize=True

    if not args.clean:
        # Make a temporary directory to store stuff
        try:
            os.mkdir(MLTMP)
        except OSError: # directory already exists
            pass

    # Sometimes we run programs in the makelatex-tmp directory and we need
    # them to see the files in the actual directory.
    os.environ['TEXINPUTS'] = os.getcwd() + os.pathsep + getEnviron('TEXINPUTS')
    os.environ['BIBINPUTS'] = os.getcwd() + os.pathsep + getEnviron('BIBINPUTS')

    # Check for uconvert in our current directory.
    os.environ['PATH'] = getEnviron('PATH')+os.pathsep+os.getcwd()

    # Set uconvert environment variables:
    os.environ['UCONVERT_DEST_DIR'] = tmpUconvertDir
    os.environ['UCONVERT_SRC_DIR']  = getEnviron("TEXINPUTS")
    # We don't want to know about makelatex-tmp/uconvert when determining
    # dependencies---we want to depend on the original files.
    os.environ['TEXINPUTS_NOTMP'] = getEnviron("TEXINPUTS")
    # LaTeX needs to know about makelatex-tmp/uconvert:
    if not os.environ['TEXINPUTS'].startswith(MLTMP+"uconvert:"):
        os.environ['TEXINPUTS']=MLTMP+"uconvert:" + getEnviron('TEXINPUTS')

    if os.path.exists(lockfile):
        print("Is this script running elsewhere? If not,")
        print("delete " + lockfile + " and try again.")
        exit(1)

    return args




# Returns true if an update is forced or if the PDF file is older than one
# (or more) files that it depends on.
def isUpdateNeeded(tex):
    pdf = texToPdf(tex)

    if args.force or not os.path.exists(pdf):
        return True

    # Find potential dependencies (at minimum, returns tex file!)
    deps = findPotentialDependencies(tex)

    # Check if anything has been modified since we made the pdf
    pdfmtime = os.stat(pdf).st_mtime

    ret = False
#    print "mtime of " + pdf + " is " + str("%.10f" % pdfmtime)
    for d in deps:
        # All of the dependencies should exist by the time we get here.
        # But, a user removing a file shouldn't cause us to try to
        # recompile the PDF and overwrite a good one that already exists.
        if not os.path.exists(d):
            continue
        # Except for the case above, all items in the
        # dependency list should actually exist because
        # we don't include things in the list that do not
        # exist.
        if os.stat(d).st_mtime > pdfmtime:
#            print "mtime of dep " + d + " is " + str("%.10f" % os.stat(d).st_mtime)
            if not args.quiet: print(outfmt % (bname(tex), fileOnly(d) + " changed; rebuilding..."))
            ret = True

    return ret


# Runs latex/pdflatex/xelatex/etc, returns true if successful if the
# command has an OK return value and if the command created the appropriate
# file (dvi for latex, pdf for pdflatex/etc.).  The resulting file will be
# put inside of the current directory (even though the arguments we pass to
# latex will initially create the file inside of the makelatex-tmp directory.
def runLatex(basename, exe=None):
    if not exe:
        exe = args.engine
    line = open(basename+".tex").readline()
    match = re.search("%\s!TEX\s*program\s*=\s*(.*)",line)
    if match:
        exe = match.group(1)


    if not args.quiet:
        print(outfmt % (basename, exe))
    command = exe + " " + LATEX_ARGS + " " + basename + " > " + MLTMP+"latex-"+basename+".log"

    if subprocess.call(['/bin/sh', '-c', command]) != 0:
        return False

    dvi = basename+".dvi"
    pdf = basename+".pdf"
    if exe == "latex" and os.path.exists(MLTMP + dvi):
        shutil.move(MLTMP + dvi, dvi)
    elif os.path.exists(MLTMP + pdf):
        shutil.move(MLTMP + pdf, pdf)

    synctex = basename + ".synctex.gz"
    if args.synctex and os.path.exists(MLTMP + synctex):
        shutil.move(MLTMP + synctex, synctex)
    else:
        removeIfExist(synctex)

    return True


def runCommand(exe, commandargs, shell=False, silentFail=False, wd=None):
    """Runs a command. If shell=True, commandargs is a string and the
    program is run in a shell. If shell=False, commandargs is a list of
    argument strings. If we can't find the exe, we either silently fail
    (and return None) or exit (with an error message)"""

    if not exe:
        printError("Internal error: runCommand() called with no exe.")
        exit(1)

    fullpath = findFileInPaths(exe)
    if fullpath == None:
        if silentFail:
            return None
        else:
            traceback.print_exc()
            printError("File \"" + exe + "\" not found in " + path)
            exit(1)
    # rudimentary security for running as shell=True
    if shell and commandargs.count(";"):
        traceback.print_exc()
        printError("Arguments cannot contain a semicolon.")
        exit(1)

    if shell:
        ps = subprocess.Popen(exe + " " + commandargs, shell=True, cwd=wd)
    else:
        exe = [ exe ]
        exe.extend(commandargs)
        ps = subprocess.Popen(exe, cwd=wd)
    return ps.wait()


# Runs latex, dvips, ps2pdf
# NOTE: Some systems have a dvipdf script which converts from dvi to pdf,
# but this is usually just a wrapper around dvips and gs
def runDvips(basename):
    if args.engine != "latex":
        return True

    dvi = basename+".dvi"
    ps = basename+".ps"

    if not os.path.exists(dvi):
        print("Can't run dvips because .dvi file doesn't exist.")
        return

    if not args.quiet:
        print(outfmt % (basename, "dvips"))

    if runCommand("dvips", "-f " + DVIPS_ARGS + " -o " + ps + " < " + dvi + " 2> " + MLTMP+"/dvips-" + basename + ".log", shell=True) != 0 or not os.path.exists(ps):
        printDvipsError(basename)
        printError("ERROR: dvips failed")
        return False
    removeIfExist(dvi)
    printDvipsError(basename)

    if not args.quiet: print(outfmt % (basename, "ps2pdf"))
    # automatically rotate all pages one way depending on text direction
    # to make landscape pages work with "-e latex"
    if not ps2pdf(PS2PDF_ARGS.replace("-dAutoRotatePages=/None",
                                      "-dAutoRotatePages=/All"),
                  ps, basename + ".pdf", optimize=False):
        printError("ERROR: Could not create PDF (is ps2pdf in PATH?).")
        return False
    removeIfExist(ps)
    return True


def removeIfExist(filename):
    """Removes a file if it exists."""
    if os.path.exists(filename):
        os.remove(filename)

def copyMetadata(src, dest):
    """Copies metadata from src to destination. src PDF is unchanged and
    dest will always exist (even if we couldn't update the metadata)."""

    if not os.path.exists(src) or not os.path.exists(dest):
        return False

    if src == dest:
        return True

    if not findFileInPaths("pdftk"):
        return False

    # ps2pdf does not copy metadata from the src pdf and adds some of its
    # own fields. If we wanted metadata to match exactly, we could clear
    # all metadata in dest and then copy it from src. However, if we remove
    # all metadata (by setting InfoValue: to blank in every entry), pdftk
    # will remove the Info dictionary entirely and refuse to add meta data
    # back in with a subsequent update_info.

    tmp = dest + ".tmp.pdf"

    # Copy metadata from src file into dest file (but store the resulting file in makelatex-tmp)
    runCommand("pdftk", src + " dump_data | pdftk " + dest + " update_info - output " + tmp, shell=True)

    if os.path.exists(tmp):
        shutil.move(tmp,dest)
        return True
    else:
        return False


def cleanupEverything(texfiles=[]):
    """Removes PDFs, tmp directory, and all of the files that latex makes
    If texfiles is empty, we will not remove PDFs."""

    # remove the makelatex-tmp directory
    if os.path.exists(MLTMP):
        shutil.rmtree(MLTMP)

    # Everything gets put into the makelatex-tmp directory except for the
    # following which sometimes get created:
    removeIfExist("missfont.log")
    removeIfExist("texput.log")

    # This is created by us if --diff option is used:
    removeIfExist("makelatex-diff.tex")

    for texfile in texfiles:
        basename = stripTexEnding(texfile)

        # remove the PDF file and any stray dvi/ps files
        # that might still be around.
        # NOTE: We also remove some common nup pdfs
        extlist = ".pdf .dvi .ps .tmp.pdf .grey.pdf " \
	    ".screen.pdf .handout.pdf " \
	    ".2x1.pdf .1x2.pdf .3x1.pdf .1x3.pdf " \
	    ".2x2.pdf .3x2.pdf .2x3.pdf .synctex.gz"
        for e in extlist.split():
            removeIfExist(basename+e)

def getPdfStatsFilename(path):
    """Returns a dictionary structure containing information about the
    given PDF."""
    if not os.path.exists(path) or not path.endswith(".pdf"):
        return None

    # Collect information in log files to use
    pdfinfo =  MLTMP + "pdfinfo-" +bname(path)+".log"
    pdffonts = MLTMP + "pdffonts-"+bname(path)+".log"
    runCommand("pdfinfo",  "\""+path+"\" > \"" + pdfinfo  + "\" 2>/dev/null", shell=True)
    runCommand("pdffonts", "\""+path+"\" > \"" + pdffonts + "\" 2>/dev/null", shell=True)

    # Print # of pages and paper size
    numPages = '?'
    pageSize = '?'
    fileSize = os.stat(path).st_size
    unembeddedFonts = 0
    nonSubsettedFonts = 0
    nonCompactFonts = 0
    type3Fonts = 0
    totalFonts = -1
    linear = False

    if findMatches([ "Optimized:(.*)yes" ], pdfinfo):
        linear = True

    for line in open(pdfinfo):
        if line.startswith("Pages:"):
            numPages = int(str(line[16:]).strip())
        if line.startswith("Page size:"):
            # use text in parenthesis if it is available
            tmp = str(line[16:]).strip()
            tmp = tmp.replace(" x ", "x")
            tmp = tmp.replace(" pts", "pts")
            if tmp.count("(") and tmp.count(")"):
                tmp = tmp.replace("(", "")
                tmp = tmp.replace(")", "")
                pageSize = tmp.split(" ")[1] + " paper"
            else:
                pageSize = tmp.split(" ")[0]


    pdfver = findMatches([ "PDF version:(.*)" ], pdfinfo)
    if pdfver[0]:
        pdfver = pdfver[0]
        pdfver = pdfver.strip()

    # Check for fonts that are not embedded or are bitmapped.
    lines = 0
    for line in open(pdffonts):
        lines += 1
    totalFonts = lines - 2

    for line in open(pdffonts):
        # Find column from end of line since some font names are really long:
        if line[-22:-19] == "no ":
            unembeddedFonts += 1
        if line[-18:-15] == "no ":
            nonSubsettedFonts += 1

    # Font types recognized by pdffonts: Type 1, Type 1C (i.e., Compact
    # Font Format, CFF), Type 3, TrueType, CID Type 0 (uncommon), CID Type
    # 0C (16 bit PostScript CFF font), CID TrueType.
    #
    # We are concerned with two different fonts:
    #
    # Type 3 - Usually bitmapped if they are coming out of LaTeX (Type 3
    # doesn't stictly mean bitmapped, however)
    #
    # Type 1 - It is better to use a compact format, Type 1C

    # Type 3 fonts are usually bitmapped when using LaTeX. However, Type 3
    # doesn't necessarily mean that that the font is bitmapped:
    # http://tex.stackexchange.com/questions/18712/why-call-type-3-font-bitmap
    for line in open(pdffonts):
        if line[37:43] == "Type 3":
            type3Fonts += 1
    for line in open(pdffonts):
        if line[37:44] == "Type 1 ":
            nonCompactFonts += 1

    return { "filename": path,
             "numPages": numPages,
             "pageSize": pageSize,
             "fileSize": fileSize,
             "unembeddedFonts": unembeddedFonts,
             "type3Fonts": type3Fonts,
             "nonCompactFonts": nonCompactFonts,
             "nonSubsettedFonts": nonSubsettedFonts,
             "totalFonts": totalFonts,
             "linear": linear,
             "pdfversion": pdfver}

def printPdfStats(stats):
    if not stats:
        return

    if stats['numPages'] == 1:
        string = "%2d %s" % (stats['numPages'], "pg;  ")
    else:
        string = "%2d %s" % (stats['numPages'], "pgs; ")

    string = string + humanSize(stats['fileSize']).rjust(6) + "; "
    string = string + stats['pageSize'] + "; "
    string = string + "PDFv" + stats['pdfversion']
    if stats['linear']:
        string = string + "(linear)"

    print(outfmt % (bname(stats['filename']), string))

    f = stats['totalFonts']
    if f > 0: string = str(f) + " font"
    if f > 1: string = string + "s"
    string = string+":"

    f = stats['unembeddedFonts']
    if f > 0: string = string + " " + str(f) + " unembedded,"
    f = stats['type3Fonts']
    if f > 0: string = string + " " + str(f) + " bitmapped,"
    f = stats['nonCompactFonts']
    if f > 0: string = string + " " + str(f) + " noncompact,"
    f = stats['nonSubsettedFonts']
    if f > 0: string = string + " " + str(f) + " nonsubsetted,"

    if stats['unembeddedFonts'] or stats['type3Fonts'] or stats['nonCompactFonts'] or stats['nonSubsettedFonts']:
        printWarn(outfmt % (bname(stats['filename']), string[0:-1]))


# Given a basename, print out statistics for any PDFs that we might have
# created.
def printPdfStatsPath(path):
    extlist = ".pdf .grey.pdf .screen.pdf .handout.pdf .2x1.pdf .1x2.pdf .3x1.pdf .1x3.pdf .2x2.pdf .3x2.pdf .2x3.pdf"
    for e in extlist.split():
        stats = getPdfStatsFilename(stripPdfEnding(path)+e)
        printPdfStats(stats)



def humanSize(num):
    for x in ['bytes','KiB','MiB','GiB','TiB']:
        if num < 1024.0:
            return "%d%s" % (round(num), x)
        num /= 1024.0


# calls ps2pdf, manages mtime properly, copies metadata from original file
# to new one. Returns true if outFile is created. Prints warning if
# metadata is not copied. If optimize=True, we will try to optimize the PDF
# after we have run the given ps2pdf command.
def ps2pdf(commandargs, infile, outfile, optimize=True):
    if not os.path.exists(infile):
        return False

    mtime = os.stat(infile).st_mtime
    command = commandargs.split()
    command.append(infile)
    command.append(outfile)

    if runCommand("ps2pdf", command, shell=False, silentFail=True) == None:
        # If ps2pdf doesn't appear to be installed, return false:
        return False

    if os.path.exists(outfile):
        if infile.endswith(".ps"):
            return True
        if not copyMetadata(infile, outfile):
            printWarn(outfmt % (bname(infile), "Might have incorrect metadata."))
        if optimize:
            optimizePdf(outfile)
        os.utime(outfile, (mtime,mtime))
        return True
    return False


# Rebuild PDF if any of the following is true:
#  * It has non-compact Type 1 fonts
#  * Fonts that are not subsetted
#  * Fonts are not embedded
#
# This runs the fonts through ps2pdf to create a PDF. Returns true
# if new PDF is created. New PDF is saved on top of the original.
def fixFonts(path):
    infile = path
    outfile = stripPdfEnding(path) + ".tmp.pdf"

    stats = getPdfStatsFilename(infile)
    if not stats or (stats['nonCompactFonts'] == 0 and stats['nonSubsettedFonts'] == 0 and stats['unembeddedFonts']==0):
        return False
# print stats before ps2pdf:
#    printPdfStats(stats)

    if not args.quiet: print(outfmt % (bname(path), "ps2pdf (try to compact/subset/embed fonts)"))
    # This process happens before optimization, so the file will get
    # subsequently optimized even with optimize=False
    if ps2pdf(PS2PDF_ARGS, infile, outfile, optimize=False):
        shutil.move(outfile, infile)
        return True
    return False



# Make a greyscale PDF if the user requested it. Returns true if file is
# successfully created.
def greyscalePdf(infile):
    if not args.greyscale:
        return True

    outfile = stripPdfEnding(infile) + ".grey.pdf"
    if not args.quiet: print(outfmt % (bname(infile), "ps2pdf (convert to greyscale)"))
    return ps2pdf(PS2PDF_ARGS_GREY, infile, outfile, optimize=True)

#  Make a screen-quality PDF if the user requested it. Returns true if file
#  is successfully created.
def screenPdf(infile):
    if not args.screen:
        return

    outfile = stripPdfEnding(infile) + ".screen.pdf"
    if not args.quiet: print(outfmt % (bname(infile), "ps2pdf (for screen-quality)"))
    if ps2pdf(PS2PDF_ARGS_SCREEN, infile, outfile, optimize=True):
        # If we created a file that is larger than the original, 
        # forget about using it...
        if os.stat(infile).st_size < os.stat(outfile).st_size:
            shutil.copyfile(infile, outfile)

    return os.path.exists(outfile)



# TODO: pdfsizeopt.py has all sorts of useful/interesting information about
# generating smaller PDFs.  We currently don't use any of it mostly because
# it seems to have many dependencies that aren't commonly installed on
# machines.
def optimizePdf(pdf):
    if not os.path.exists(pdf):
        return

    # Always try to embed/compact/subset fonts, regardless
    # of if optimize flag is set:
    mtime = os.stat(pdf).st_mtime
    fixFonts(pdf)
    os.utime(pdf, (mtime,mtime))

    if not args.optimize:
        return

    # Linearize the PDF
    mtime = os.stat(pdf).st_mtime
    optimizePdfopt(pdf)
    os.utime(pdf, (mtime,mtime))



# Linearizes a PDF using pdfopt command. Silently fails.
def optimizePdfopt(path):
    orig = path
    opt = MLTMP + bname(path) + ".opt.pdf"

    if getPdfStatsFilename(orig)['linear']:
        return
    # a list of [ command, args ] for programs which linearize PDFs:
    options = [ [ "qpdf", [ "--linearize", orig, opt ] ],
                [ "pdfopt", [ orig, opt ] ] ]

    for o in options:
        if findFileInPaths(o[0]):
            if not args.quiet: print(outfmt % (bname(path), o[0] + " linearized the PDF"))
            runCommand(o[0], o[1], shell=False, silentFail=True)
            if os.path.exists(opt):
                shutil.move(opt, orig)
            return


# Runs makeindex if necessary. Returns True/False depending on if we had to
# run makeindex, exits on error.
def runMakeindex(basename):

    # a list of [ exten, command, args ]. Runs command+args when
    # basename.exen is present.
    options = [ [ ".idx", "makeindex", [ "-q", "-t", MLTMP+"makeindex-" + basename + ".log", MLTMP + basename + ".idx" ] ],
                # nomencl.sty:
                [ ".nlo", "makeindex", [ "-q", "-t", MLTMP+"makeindex-"+basename+".log", MLTMP + basename + ".nlo", "-s", "nomencl.ist", "-o", MLTMP + basename + ".nls" ] ] ]

    for o in options:
        if os.path.exists(MLTMP + basename + o[0]):
            if not args.quiet: print(outfmt % (basename, o[1]))
            if runCommand(o[1], o[2], shell=False, silentFail=False) != 0:
                print(open(MLTMP + o[1]+basename+".log").read())
                exit(1)
            return True
    return False



# Runs makeglossaries if necessary. Returns True/False depending on if we had to
# run makeglossaries, exits on error.
def runMakeglossaries(basename):
    if not os.path.exists(MLTMP + basename + ".glo"):
        return False

    if not args.quiet: print(outfmt % (basename, "makeglossaries"))

    if runCommand("makeglossaries", basename + "> makeglossaries-" + basename + ".log", shell=True, wd=MLTMP) != 0:
        print(open(MLTMP+"makeglossaries-" + basename + ".log").read())
        exit(1)

    return True

# Runs bibtex if necessary. Returns True/False depending on if we had to
# run bibtex, exits on error.
def runBibtex(basename):
    bibtexargs = findMatches( [ "^No file (.*)\.bbl" ], MLTMP+basename+".log")
    if len(bibtexargs) == 0:
        return False

    exe = findFileInPaths("bibtex8")
    if not exe:
        exe = "bibtex"

    for basename in bibtexargs:
        if not args.quiet: print(outfmt % (basename, bname(exe)))
        # bibtex8 returns 0 for OK run, 1 for warnings, 2 for errors
        # bibtex returns 0 for OK run/warnings, 2 for errors
        if runCommand(exe, basename + "> bibtex-" + basename+".log", shell=True, wd=MLTMP) > 1:
            print(open(MLTMP+"bibtex-"+basename+".log").read())
            exit(1)

        else:
            for line in open(MLTMP+"bibtex-"+basename+".log"):
                if line.startswith("Warning--") or line.startswith("Repeated entry---"):
                    print(bcolors.WARN + basename+": "+ bcolors.ENDC + line.strip())


    return True


# Print latex warnings and errors
def printLatexWarn(basename):

    if os.path.exists(MLTMP+basename+".log"):
        with open(MLTMP+basename+".log") as f:
            lines = f.readlines()

        errMsg = [ "Missing character" ]
        for e in errMsg:
            for l in lines:
                if re.search(e,l):
                    print(bcolors.WARN + basename+": " + bcolors.ENDC + l.rstrip())

    with open(MLTMP+"latex-"+basename+".log") as f:
        lines = f.readlines()

    # numbers are the number of lines before and after the
    # matching line to print.
    errMsg = [ [ 0, 0, "Overfull"],
               [ 0, 0, "Underfull"],
               [ 0, 0, "Warning:"],
               [ 0, 0, "Error:"],
               [ 0, 0, "LaTeX Error"],
               [ 0, 0, "! I can't"],
               [ 0, 0, "!pdfTeX error"],
               [ 0, 0, "Fatal"],
               [ 0, 0, "not defined"],
               [ 0, 0, "undefined"],
               [ 0, 0, "improper"],
               [ 0, 0, "required"],
               [ 0, 0, "requires"],
               [ 0, 0, "You must"],
               [ 0, 0, "Fatal format file error"],
               [ 0, 0, "This exam"], # exam.cls
               [ 0, 0, "No file"],
               [ 1, 1, "LaTeX Warning"],
               [ 1, 1, "pdfTeX Warning"],
               [ 0, 2, "Package fontspec Warning:"],
               [ 0, 1, "Undefined control sequence"],
               [ 0, 1, "Runaway argument"],
               [ 0, 4, "./" + basename + ".tex:" ],
               [ 0, 2, "./" + basename + ".bbl:" ] ]

    linesToPrint = []
    for e in errMsg:
        for l in range(len(lines)):
            if re.search(e[2],lines[l], flags=re.IGNORECASE):
                # Don't warn about missing basename.aux
                #
                # Hide common xelatex error (TODO: Remove this check when
                # problem is fixed:
                # http://tex.stackexchange.com/questions/46683/
                if lines[l].strip() != "No file " + basename + ".aux." and not re.search("xparse/redefine-command", lines[l]):
                    linesToPrint.extend( range(l-e[0], l+e[1]+1) )

    # we may have selected to print the same line twice, and our ranges may
    # be out of bounds. Also, we may have selected some blank lines to
    # print.  Remove duplicates and print non-empty lines:
    linesToPrint = dedup(linesToPrint)
    linesToPrint.sort()
    for l in linesToPrint:
        if l>=0 and l<len(lines) and len(lines[l].strip()) > 0:
            print(bcolors.WARN + basename+": " + bcolors.ENDC + lines[l].rstrip())


def printDvipsError(basename):
    if os.path.exists(MLTMP+basename+".log"):
        with open(MLTMP+basename+".log") as f:
            lines = f.readlines()

    errMsg = [ [ 1, 1, "\(Mismatched mode\)"],
               [ 0, 0, "\(may be too complex to print\)"] ]

    linesToPrint = []
    for e in errMsg:
        for l in range(len(lines)):
            if re.search(e[2],lines[l]):
                linesToPrint.extend( range(l-e[0], l+e[1]+1) )

    # we may have selected to print the same line twice, and our ranges may
    # be out of bounds. Also, we may have selected some blank lines to
    # print.  Remove duplicates and print non-empty lines:
    linesToPrint = dedup(linesToPrint)
    linesToPrint.sort()
    for l in linesToPrint:
        if l>=0 and l<len(lines) and len(lines[l].strip()) > 0:
            printWarn(basename + ": " + lines[l].strip())




def needsRerun(basename, printMessages=False):
    string = open(MLTMP+"latex-"+basename+".log").read()
    msg = [ 'LaTeX Warning: Label\(s\) may have changed',
            "Citation.*undefined.*",
            "No file " + basename + ".toc", # table of contents
            "No file " + basename + ".nav", # beamer presentation
            "Rerun to get",
            "LaTeX Warning: There were undefined references",
            "Package natbib Warning: There were undefined citations.",
            "Package natbib Warning: Citation\(s\) may have changed." ]

    # if printMessages, print all messages:
    if printMessages:
        for m in msg:
            if re.search(m, string):
                printWarn(outfmt % (basename, re.search(m,string).group(0)))

    # search again, if we find a message, return True.
    for m in msg:
        if re.search(m, string):
            return True
    return False


# Removes duplicates in list
def dedup(listin):
    out = []
    for i in listin:
        if out.count(i) == 0:
            out.append(i)
    return out


# Finds matches, removes duplicates, returns matching strings
# Example: findMatches(["foo(.*)bar", "bar(.*)foo" ], filename)
def findMatches(regexs, filename):
    matches = []
    try:
        for r in regexs:
            f = open(filename)
            for line in f:
                matches.extend(re.findall(r, line))
            f.close()
    except IOError:
        printError("Error opening or reading file: " + filename)
        printWarn("NOTE: makelatex may not work properly if you do not change into the directory which contains the document before you run it.")
        exit(1)
    return dedup(matches)


# Returns a list of images in the texfiles.  The strings returned
# are exactly how they appear in the texfile.  (i.e., they may
# be missing extensions)
def getImagesInTexFiles(texfiles):
    ret = []
    for i in texfiles:
        if not i.endswith(".pdf"):
            ret.extend(findMatches([ "^[^%]*\\\\includegraphics\[[^]]*\]{([^}]*)}",
                                     "^[^%]*\\\\includegraphics{([^}]*)}" ], i))
    return dedup(ret)

# Returns a list of images in a single texfile
def getImagesInTexFile(texfile):
    return getImagesInTexFiles([texfile])



# Returns a list of .sty files, .bib files, included .tex files, and
# included .pdf files in the latex document.  The files returned by this
# function are either absolute paths or relative paths beginning with "./"
def getIncludedInTex(texfile, depth=3):
    incList = []

    if texfile.startswith("/"):
        incList.append(texfile)
    else:
        incList.append(findFileInPaths(texfile, getEnviron('TEXINPUTS')))

    if depth <= 0:
        return incList

    matches = []
    matches.extend(findMatches(["^[^%]*\\\\bibliography{(.*)}"], texfile))

    # Include the graphicspath in our TEXINPUTS path so uconvert can find images
    # Format: \graphicspath{{path1/}{path2/}{path3/}}
    # The trailing / after each path is required
    #
    # TODO: This means that the path applies to all .tex files we are
    # building---which may not be intended.
    gpath = findMatches(["^[^%]*\\\\graphicspath{{(.*)}}"], texfile)
    for i in gpath:
        entries = i.split('}{');
        currentInputs = getEnviron("TEXINPUTS").split(os.pathsep)
        for e in entries:
            if currentInputs.count(e) == 0:
                os.environ["TEXINPUTS"] =       e + os.pathsep + getEnviron("TEXINPUTS")
                os.environ["TEXINPUTS_NOTMP"] = e + os.pathsep + getEnviron("TEXINPUTS_NOTMP")
                os.environ['UCONVERT_SRC_DIR']= getEnviron("TEXINPUTS")


    # multibib support: find other bibtex files that are used
    mbibNames = findMatches(["^[^%]*\\\\newcites{(.*)}{.*}"], texfile)
    for i in mbibNames:
        matches.extend(findMatches(["^[^%]*\\\\bibliography"+i+"{(.*)}"], texfile))
    matches = dedup(matches)
    for match in matches:
        for s in match.split(","):  # multiple files can be comma delimited
            name = findFileInPaths(s+".bib", getEnviron('BIBINPUTS'))
            if name and incList.count(name) == 0:
                incList.append(name)

    texinputs = getEnviron('TEXINPUTS_NOTMP')

    matches = findMatches(["^[^%]*\\\\usepackage\[.*\]{([^}]*)}",
                           "^[^%]*\\\\usepackage{([^}]*)}" ], texfile)
    for match in matches:
        for s in match.split(","):  # multiple packages can be comma delimited
            name = findFileInPaths(s+".sty", texinputs)
            if not name:
#                if not findFileInPaths(s+".sty", texinputs, kpathsea=True):
#                    printWarn("Potential dependency is missing: "+s+".sty" + " needed by "+texfile)
                continue
            if incList.count(name) == 0:
                incList.extend(getIncludedInTex(name, depth=depth-1))

    matches = findMatches(["^[^%]*\\\\RequirePackage\[.*\]{([^}]*)}",
                           "^[^%]*\\\\RequirePackage{([^}]*)}"], texfile)
    for match in matches:
        for s in match.split(","):  # multiple packages can be comma delimited
            name = findFileInPaths(s+".sty", texinputs)
            if not name:
#                if not findFileInPaths(s+".sty", texinputs, kpathsea=True):
#                    printWarn("Potential dependency is missing: "+s+".sty" + " needed by "+texfile)
                continue
            if incList.count(name) == 0:
                # recursively handle dependencies (and find the images in the file)
                incList.extend(getIncludedInTex(name, depth=depth-1))

    # NOTE: \input will basically copy/paste the contents of the other file
    # into the current file.  \include will render the included information
    # seperately (i.e., force a page break after the included content).
    matches = findMatches(["^[^%]*\\\\input{([^}]*)}",
                           "^[^%]*\\\\include{([^}]*)}"], texfile)
    for match in matches:
        exten = [ "", ".tex" ]   # TODO: Remove extensions first?
        for e in exten:
            name = findFileInPaths(match + e, texinputs)
            if not name:
#                if not findFileInPaths(match+e, texinputs, kpathsea=True):
#                    printWarn("Potential dependency is missing: "+match+e + " needed by "+texfile)
                continue
            if incList.count(name) == 0:
                incList.append(name)
                # recursively handle dependencies:
                incList.extend(findPotentialDependencies(name, depth=depth-1))

    matches = findMatches([ "^[^%]*\\\\includepdf\[.*\]{(.*)}",
                            "^[^%]*\\\\includepdf{(.*)}" ], texfile)
    for s in matches:
        # file extension is optional in \includepdf so we'll deal
        # with both cases.
        if not s.endswith(".pdf"):
            s = s+".pdf"
        # find the PDF
        name = findFileInPaths(s, texinputs)
        # if PDF file isn't found, look for a tex file that we could
        # potentially use to create it
        if not name:
            name = findFileInPaths(stripPdfEnding(s)+".tex", texinputs)
        # Add a dependency on the PDF if we found a matching PDF or tex file.
        if name:
            incList.append(name)

    return incList


def findFileInPaths(name, paths=None, kpathsea=False):
    """Given a colon-delimited set of paths and a filename, look for the
    file in the paths and return path (or None if it doesn't exist in
    paths). If kpathsea is set, we look for tex system files that match."""
    if not paths:
        paths = getEnviron('PATH')

    if kpathsea:
        origEnviron = getEnviron("TEXINPUTS")
        os.environ["TEXINPUTS"]=paths
        path = os.popen("kpsewhich \""+name+"\"").read().strip()
        os.environ["TEXINPUTS"]=origEnviron
        if len(path):
            return path
        else:
            return None

    for path in paths.split(os.pathsep):
        f = os.path.join(path, name)
        if os.path.exists(f):
            return f
    return None


# Returns a list of files used by a tex file. This list is primarily used
# only to determine if some of the files that we depend on have changed
# since we created the last PDF.
#
# * It doesn't hurt (much) if we include files that aren't actually
#   dependencies.
#
# * Paths to files will be absolute or begin with ./
#
# * Some of the files returned by this function may not exist (example: If
# * the user did an \includepdf{b} and b.pdf doesn't exist, but b.tex does
# * (i.e., user is expecting us to make b.pdf for them).
#
# * All of the image files that we return will exist. If we can't find the
# * source image, we don't know what extension the user intended to use
# * because anything they have inside of includegraphics could have any
# * number of extensions added to it!
#

def findPotentialDependencies(texfile, depth=3):
    depend = []
# This isn't ideal because we don't know the file extension that we are
# looking for. The convertImages() function will actually do the conversion
# of these files to a latex-appropriate format. We should look for highest
# quality files first!
    exten = [ "", ".svg", ".svgz", ".eps", ".ps",
              ".pdf", ".mp", ".mps", ".png", ".gif",
              ".tif", ".tiff", ".bmp", ".jpg", ".jpeg" ]
    images = getImagesInTexFile(texfile)
    for i in images:
        for e in exten:
            f = findFileInPaths(i + e, getEnviron('TEXINPUTS_NOTMP'))
            if f:
                depend.append(f)

    depend.extend(getIncludedInTex(texfile, depth))

    if os.path.exists("./prepost.sh"):
        depend.append("./prepost.sh")

    depend = dedup(depend)

    return depend

# Performs the opposite of path.os.expanduser(): Changes /home/username
# into ~.
def compressuser(path):
    return re.sub(os.path.expanduser('~'), '~', path)

# Put lossy file formats (like JPG) at the end of the list.
def supportedImageExten(engine):
# NOTE: If a .mp (metapost) image file is present, we will request a .ps or
# .mps file from uconvert (depending on engine). Otherwise, we assume that
# everybody should be using one of the formats below when including
# imagery.
    if engine == "latex":
        return ".eps".split(" ")
    if engine == "pdflatex":
        return ".pdf .png .jpg".split(" ")
    if engine == "lualatex":
        return ".pdf .png .jpg".split(" ")
    if engine == "xelatex":
        return ".eps .pdf .png .jpg".split(" ")

def convertImages(texfiles):
    if args.noconvert:
        return

    # If force requested, remove any images that already exist
    if args.force and os.path.exists(tmpUconvertDir):
        shutil.rmtree(tmpUconvertDir)

    # Generate the list of images (with extensions) that we need.  Since
    # latex allows you to include images without specifying extensions and
    # because different engines support different file formats, this gets
    # a little complex:
    imageWithExten = []

    # The tex files may include other tex files that include images
    texfilesWithDep = []
    for t in texfiles:
        texfilesWithDep.extend(getIncludedInTex(t))

    for image in getImagesInTexFiles(texfilesWithDep):
        # image is the image name as it appears in the tex file!
        imageLow = image.lower()

        # If the user specified an extension supported by the engine, then
        # we know the file we need to create. We will add the file to
        # imageWithExten list and move on to the next image.
        okExten = False
        for i in supportedImageExten(args.engine):
            if not okExten and imageLow.endswith(i):
                imageWithExten.append(image)
                okExten = True

        if okExten:
            continue

        # If we get to here, the string doesn't have an extension, or it
        # has one and it doesn't work with the engine.

        # It looks like there is an 2 or 3 character extension, print
        # warning and do what user requested.
        if len(image) > 4 and (image[-3]=='.' or image[-4]=='.'):
            printWarn("WARNING: \"" + image + "\" might not be supported by the \"" + args.engine + "\" engine .")
            printWarn("Suggestion: Don't specify an extension and let this script handle conversions.")
            # If they specified it, trust the user and forget uconvert:
            imageWithExten.append(image)
            continue

        # Now, we are confident that there is no extension

        # Look for an existing image file that is in the format that is
        # supported by our engine.
        choices = []
        paths = getEnviron('TEXINPUTS_NOTMP')
        for i in supportedImageExten(args.engine):
            choices.append(findFileInPaths(image+i, paths))
        while None in choices:
            choices.remove(None)

        # If we can't find an appropriate file that already exists, we'll
        # ask uconvert to make us a pdf (or eps) from all of the file
        # formats it supports. Of course, it might fail!
        if len(choices)==0:
            # Differt engines prefer .mp files to be converted differently.
            if findFileInPaths(image+".mp", paths):
                if args.engine == "latex" or args.engine == "xelatex":
                    imageWithExten.append(image+".ps")
                else:
                    imageWithExten.append(image+".mps")

            # Otherwise, if using latex engine, ask uconvert for a EPS:
            elif args.engine == "latex":
                imageWithExten.append(image+".eps")
            else:
                # If using any other engine, ask uconvert for a PDF
                # (TODO: Is this arbitrary choice is best?)
                imageWithExten.append(image + ".pdf")
        else:
            # If we found an existing image in a supported format, use it.
            exten = "." + choices[0].rsplit(".", 1)[1]
            imageWithExten.append(image + exten)

    # Now, imageWithExten contains all of the images that we are going to
    # use with the document.

    try: # Create directory for converted images:
        os.mkdir(tmpUconvertDir)
    except OSError: # directory already exists
        pass

    if len(imageWithExten) == 0:
        return

    # Do the conversion:
    commandargs = []
    if args.quiet:
        commandargs = [ "-q" ]
    commandargs.extend(dedup(imageWithExten))
    if runCommand("uconvert", commandargs, shell=False) != 0:
        printWarn("WARNING: Failed to convert one or more images.")

# paramName = actual parameter provided to makelatex
# paramValue = true/false or the string given with the param to makelatex
# command = The command that we need to run
# otherCommandArgs = Extra parameters we need to give pdfnup.
# path = full path to file to create nup from
# extension = basename.extension.pdf will be used to store the output file
def createNupCommand(paramName, paramValue, command, otherCommandArgs, path, extension):
    if not paramValue:
        return
    if not findFileInPaths(command):
        printError(command + " command is needed for " + paramName)
        return
    outfile = bname(path)+"."+extension+".pdf"
    commandargs = ["--outfile", outfile]
    commandargs.extend(PDFNUP_ARGS.split())
    commandargs.extend(otherCommandArgs)
    # use same paper size as input PDF if it is letter or A4
    pageSize = getPdfStatsFilename(path)['pageSize']
    if pageSize == "letter paper":
        commandargs.extend(["--paper", "letterpaper"])
    elif pageSize == "A4 paper":
        commandargs.extend(["--paper", "a4paper"])
    else: # otherwise, use the hardcoded variable indicating paper size
        commandargs.extend(["--paper", PDFNUP_PAPER])
    commandargs.append(path)  # input file
    if not args.quiet: print(outfmt % (bname(path), "pdfnup"))
    runCommand(command, commandargs, shell=False)

    optimizePdf(outfile)


def createNupHandout(path):
    createNupCommand("--nupHandout", args.nupHandout, "pdfjam-slides3up",
                     [], path, "handout")

def createNupLand(path):
    createNupCommand("--nupLand", args.nupLand, "pdfnup",
                     [ "--scale", ".85", "--landscape", "--nup", args.nupLand ],
                     path, args.nupLand)

def createNupPort(path):
    createNupCommand("--nupPort", args.nupPort, "pdfnup",
                     [ "--scale", ".85", "--no-landscape", "--nup", args.nupPort ],
                     path, args.nupPort)


def createNup(path):
    """Create the requested nup PDFs given a path to the source PDF."""
    if not os.path.exists(path):
        return
    createNupHandout(path)
    createNupPort(path)
    createNupLand(path)



def processTexFile(path):
    """Generates a PDF from the given tex file. Returns true if PDF was
    successfully created."""
    if not os.path.exists(path):
        printError("ERROR: Latex source file does not exist: " + path)
        return

    basename = bname(path)
    # runOK will be true even if there were undefined references, etc
    runOK = runLatex(basename)

    if not runOK:
        printLatexWarn(basename)
        printError("ERROR: Latex indicated an error (but PDF may have been created).")
        printWarn("Suggestion: If you don't see errors above, run makelatex with -fk options and look in log files stored in the \"" + MLTMP + "\" subdirectory.")

        # Sleep for 5 seconds if we are looping so that we don't just
        # repeatedly recompile the file over and over again.
        #
        # TODO: We could do something better. For example, we could get the
        # mtime of all the source files here, and then wait until the mtime
        # on one of the files changed before attempting to recompile.
        if args.loop:
            time.sleep(5)
        return False

    # If we have to run bibtex or makeindex, we have to rerun latex at
    # least one time
    mustRunAgain = runBibtex(basename)
    mustRunAgain = mustRunAgain + runMakeindex(basename)
    mustRunAgain = mustRunAgain + runMakeglossaries(basename)
    if mustRunAgain:
        runLatex(basename)

    # Run latex in a loop up to 5 times if needed
    count = 5
    while count > 0:
        if(needsRerun(basename)):
            count = count-1
            runOK = runLatex(basename)
        else:
            count = -100


    printLatexWarn(basename)

    if count == 0: # if there were undefined references, print them out
        needsRerun(basename, printMessages=True)
        return False

    # If last run failed or if PDF is missing, we failed.
    if not runOK:
        printError(outfmt % (basename, "ERROR: Failed to create PDF"))
    else:
        runDvips(basename)   # Convert dvi to pdf if necessary
        # The commands change the modified time of the PDF, set it back to
        # the time we started to build the PDF:
        updatePdfMtime(basename)

    return runOK



def updatePdfMtime(path):
    if not os.path.exists(path):
        return

    # makes the PDF mtime and atime match the time we started this script
    os.utime(path, (makelatex_start_time, makelatex_start_time))

    # Evince doesn't seem to automatically reload the file unless we
    # update the access time with the "touch" command.
    runCommand("touch", [ "-a", path ], shell=False)
# The above touch command should be the same as running the
# following, but "touch" works and the following doesn't for some
# reason...
# os.utime(path, (time.time(), makelatex_start_time))


def callFunctionWithThreads(funcName, funcArgs):
    """Calls a function multiple times---once with each argument. If
    threads are requested, we call each function in its own thread."""
    if len(funcArgs) == 0:
        return

    for i in funcArgs:
        if not args.threads:
            funcName(i)
        else:
            threading.Thread(target=funcName,args=(i,)).start()

    # wait for all threads to finish if we're using threading
    if args.threads:
        while threading.activeCount() > 1:
            time.sleep(.2)


def findNonAsciiChars(files):
    """Given a list of files, print out lines wh ich contain non-ASCII
    characters"""
    if args.nonascii or args.quiet:
        return

    # Find sty and bib files that the tex files use:
    asciiToCheck = []
    for f in files:
        asciiToCheck.append(f)
        deps = findPotentialDependencies(f)
        for d in deps:
            if d.endswith(".sty") or d.endswith(".bib"):
                asciiToCheck.append(d)

    havePrintedMessage = False
    for f in asciiToCheck:
        try:
            lineNo = 0
            for line in open(f):
                lineNo = lineNo+1
                if not all(ord(c) < 128 for c in line):
                    if not havePrintedMessage:
                        havePrintedMessage = True
                        printWarn("Non-ASCII characters in file:")
                    sys.stdout.write(bcolors.WARN + f + ":" + str(lineNo) + bcolors.ENDC + ": ")
                    for c in line:
                        if ord(c) < 128:
                            sys.stdout.write(c)
                        else:
                            sys.stdout.write(bcolors.WARN + c + bcolors.ENDC)


        except IOError:
            pass

def processTexFiles():
    """Determines which tex files the that we should create PDFs for and
    creates them."""

    if os.path.exists("./prepost.sh"):
        subprocess.call(['./prepost.sh', "pre"])

    files = getTexFiles()
    findNonAsciiChars(files)
    makeSuggestions(files)

    # Update the time we started in a global variable---used to set mtime
    # of pdfs we create.
    global makelatex_start_time
    makelatex_start_time = time.time()

    triedToBuild = [] # list of tex files we tried to build

    # We need this outside loop to correctly rebuild files that have
    # \includepdf. For example if a.tex has \includepdf{b.pdf} and b
    # changes, we will only rebuild B.pdf the first time through the loop.
    # The second time through the loop, B.pdf will have changed and we will
    # detect that A needs to be rebuilt too.
    origForceFlag = args.force
    for j in range(0,10):
        # Print message if no texfiles
        texfilelist = getTexFiles()
        if len(texfilelist) == 0:
            printError("ERROR: No files given as arguments, no tex files found.")
            return

        # Prune the texfile list to just the files that need updating AND
        # the files that we haven't already tried to build in a previous
        # time through the loop.  This is needed because if we failed to
        # build a file, we would repeatedly try to build it inside of the
        # above loop.  If force flag is set, isUpdateNeeded() will always
        # return true.
        needUpdate = []
        for texfile in texfilelist:
            if triedToBuild.count(texfile) == 0 and isUpdateNeeded(texfile):
                needUpdate.append(texfile)
        texfilelist = needUpdate

        # break out of loop when nothing to update
        if len(texfilelist) == 0:
            break

        # If the same image is in multiple tex files, we only want to
        # convert the image once.  Therefore, convert the images here
        # instead of doing it in the loop below which uses seperate threads
        # per document.  (NOTE: uconvert uses one thread per image if
        # multiple images are being converted).
        convertImages(texfilelist)

        # Create pdfs from each tex file
        for i in texfilelist:
            triedToBuild.append(i)

        callFunctionWithThreads(processTexFile, texfilelist)

        # Ignore the --force flag after first time through loop.
        if args.force:
            args.force=False
    # Restore force flag to whatever it was before
    # the loop.
    args.force = origForceFlag

    # Optimize PDF and create nup versions regardless of if files need
    # updating.
    texfilelist = getTexFiles()
    if len(texfilelist) > 0:
        pdffilelist = list(map(texToPdf, texfilelist))
        callFunctionWithThreads(optimizePdf, pdffilelist)
        callFunctionWithThreads(greyscalePdf, pdffilelist)
        callFunctionWithThreads(screenPdf, pdffilelist)
        callFunctionWithThreads(createNup, pdffilelist)

    # Print all of the stats together at the end so they don't get buried
    # in all of the output.  Don't show messages if we are looping due to
    # "-l" option and we didn't need to build anything this time through
    # the loop.
    for i in texfilelist:
        if not args.loop or (args.loop and len(triedToBuild) > 0):
            printPdfStatsPath(texToPdf(i))

    if os.path.exists("./prepost.sh"):
        subprocess.call(['./prepost.sh', "post"])



# Remove lockfile. Automatically called when exit() is called.
def cleanupLock():
    removeIfExist(lockfile)
    # Remove makelatex-tmp now unless user requested that we keep it
    if not args.keep:
        cleanupEverything()
    if args.loop and requestedOptimize:
        printWarn("Rerun without --loop or -l to optimize PDF.")
        printWarn("  (Makelatex disables optimization when looping is used.)")



def main():
    initialSetup()

    atexit.register(cleanupLock) # cleanup lockfile on exit()
    l = open(lockfile, "w") # create lockfile
    l.close()


    try: # catch ctrl+c interrupt below
        if args.clean:
            # prepost.sh can make a tex file, so we need to
            # make it to detect all the pdfs that we could
            # remove:
            if os.path.exists("./prepost.sh"):
                subprocess.call(['./prepost.sh', "pre"])
            cleanupEverything(getTexFiles())
            removeIfExist("makelatex-diff.pdf") # getTexFiles() may not contain makelatex-diff.tex---since we delete it.
            if os.path.exists("./prepost.sh"):
                subprocess.call(['./prepost.sh', "post"])
            exit(0)

        if args.loop:
            while True:
                processTexFiles()
                time.sleep(1)

        else:
            processTexFiles()

    except KeyboardInterrupt:
        if os.path.exists("./prepost.sh"):
            subprocess.call(['./prepost.sh', "interrupt"])
        print("")
        print("makelatex: Cleaning up...")
        exit(1)

if __name__ == '__main__':
    main()

